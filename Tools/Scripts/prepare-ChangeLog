#!/usr/bin/env perl
# -*- Mode: perl; indent-tabs-mode: nil; c-basic-offset: 2  -*-

#
#  Copyright (C) 2000, 2001 Eazel, Inc.
#  Copyright (C) 2002-2021 Apple Inc.  All rights reserved.
#  Copyright (C) 2009 Torch Mobile, Inc.
#  Copyright (C) 2009 Cameron McCormack <cam@mcc.id.au>
#
#  prepare-ChangeLog is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2 of the License, or (at your option) any later version.
#
#  prepare-ChangeLog is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public
#  License along with this program; if not, write to the Free
#  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#


# Perl script to create a ChangeLog entry with names of files
# and functions from a diff.
#
# Darin Adler <darin@bentspoon.com>, started 20 April 2000
# Java support added by Maciej Stachowiak <mjs@eazel.com>
# Objective-C, C++ and Objective-C++ support added by Maciej Stachowiak <mjs@apple.com>
# Git support added by Adam Roben <aroben@apple.com>
# --git-index flag added by Joe Mason <joe.mason@torchmobile.com>


#
# TODO:
#   Decide what a good logical order is for the changed files
#     other than a normal text "sort" (top level first?)
#     (group directories?) (.h before .c?)
#   Handle yacc source files too (other languages?).
#   Help merge when there are ChangeLog conflicts or if there's
#     already a partly written ChangeLog entry.
#   Add command line option to put the ChangeLog into a separate file.
#   Add SVN version numbers for commit (can't do that until
#     the changes are checked in, though).
#   Work around diff stupidity where deleting a function that starts
#     with a comment makes diff think that the following function
#     has been changed (if the following function starts with a comment
#     with the same first line, such as /**)
#   Work around diff stupidity where deleting an entire function and
#     the blank lines before it makes diff think you've changed the
#     previous function.

use strict;
use warnings;

use File::Basename;
use File::Spec;
use FindBin;
use Getopt::Long;
use lib $FindBin::Bin;
use List::Util qw/max/;
use POSIX qw(strftime);
use VCSUtils;
use webkitperl::changelog;

sub changeLogDate($);
sub changeLogEmailAddressFromArgs($$);
sub changeLogNameFromArgs($$);
sub createPatchCommand($$$$);
sub determinePropertyChanges($$$);
sub diffCommand($$$$);
sub diffFromToString($$$);
sub fetchBugXMLData($$);
sub findChangeLogs($$);
sub findOriginalFileFromSvn($);
sub generateFileList(\%$$$\%);
sub generateFunctionLists($$$$$);
sub generateNewChangeLogs($$$$$$$$$$$$$$$);
sub getLatestChangeLogs($);
sub get_function_line_ranges_for_cpp($$);
sub delete_namespaces_from_ranges_for_cpp(\@\@);
sub is_function_in_namespace($$);
sub get_function_line_ranges_for_java($$);
sub get_function_line_ranges_for_javascript($$);
sub get_function_line_ranges_for_perl($$);
sub get_selector_line_ranges_for_css($$);
sub get_function_line_ranges_for_swift($$);
sub isAddedStatus($);
sub isConflictStatus($$$);
sub isModifiedStatus($);
sub isUnmodifiedStatus($);
sub main();
sub method_decl_to_selector($);
sub normalizeLineEndings($$);
sub openChangeLogs($);
sub originalFile($$$$);
sub pluralizeAndList($$@);
sub printDiff($$$$);
sub processPaths(\@);
sub propertyChangeDescription($);
sub resolveChangeLogsPath($@);
sub resolveConflictedChangeLogs($);
sub reviewerAndDescriptionForGitCommit($$);
sub statusCommand($$$$);
sub statusDescription($$$$);
sub svnUpdateCommand(@);
sub testListForChangeLog(@);

### Constant variables.
# Project time zone for Cupertino, CA, US
use constant ChangeLogTimeZone => "PST8PDT";
use constant SVN => "svn";
use constant GIT => "git";
use constant SupportedTestExtensions => {map { $_ => 1 } qw(html shtml svg xml xhtml pl php)};

exit(main());

sub main()
{
    my %attributeCache;
    my $bugDescription;
    my $bugRadarURL;
    my $bugNumber;
    my $name;
    my $emailAddress;
    my $mergeBase = 0;
    my $gitCommit = 0;
    my $gitIndex = "";
    my $gitReviewer = "";
    my $checkWebKitStyle = 0;
    my $openChangeLogs = 0;
    my $writeChangeLogs = 1;
    my $delimiters = 0;
    my $showHelp = 0;
    my $spewDiff = $ENV{"PREPARE_CHANGELOG_DIFF"};
    my $updateChangeLogs = 1;
    my $onlyFiles = 0;
    my $parseOptionsResult =
        GetOptions("diff|d!" => \$spewDiff,
                   "bug|b:i" => \$bugNumber,
                   "delimiters" => \$delimiters,
                   "description:s" => \$bugDescription,
                   "name:s" => \$name,
                   "email:s" => \$emailAddress,
                   "merge-base:s" => \$mergeBase,
                   "git-commit|g:s" => \$gitCommit,
                   "git-index" => \$gitIndex,
                   "git-reviewer:s" => \$gitReviewer,
                   "help|h!" => \$showHelp,
                   "style!" => \$checkWebKitStyle,
                   "open|o!" => \$openChangeLogs,
                   "write!" => \$writeChangeLogs,
                   "update!" => \$updateChangeLogs,
                   "only-files" => \$onlyFiles);
    if (!$parseOptionsResult || $showHelp) {
        print STDERR basename($0) . " [-b|--bug=<bugid>] [-d|--diff] [-h|--help] [-o|--open] [-g|--git-commit=<committish>] [--git-reviewer=<name>] [svndir1 [svndir2 ...]]\n";
        print STDERR "  -b|--bug        Fill in the ChangeLog bug information from the given bug.\n";
        print STDERR "  --description   One-line description that matches the bug title.\n";
        print STDERR "  -d|--diff       Spew diff to stdout when running\n";
        print STDERR "  --merge-base    Populate the ChangeLogs with the diff to this branch\n";
        print STDERR "  -g|--git-commit Populate the ChangeLogs from the specified git commit\n";
        print STDERR "  --git-index     Populate the ChangeLogs from the git index only\n";
        print STDERR "  --git-reviewer  When populating the ChangeLogs from a git commit claim that the spcified name reviewed the change.\n";
        print STDERR "                  This option is useful when the git commit lacks a Signed-Off-By: line\n";
        print STDERR "  -h|--help       Show this help message\n";
        print STDERR "  --[no-]style    Run check-webkit-style script when done (default: no-style)\n";
        print STDERR "  -o|--open       Open ChangeLogs in an editor when done\n";
        print STDERR "  --[no-]update   Update ChangeLogs from svn before adding entry (default: update)\n";
        print STDERR "  --[no-]write    Write ChangeLogs to disk (otherwise send new entries to stdout) (default: write)\n";
        print STDERR "  --delimiters    When writing to stdout, label and print a \"~\" after each entry\n";
        print STDERR "  --email=        Specify the email address to be used in the patch\n";
        print STDERR "  --only-files    Exclude the standard changelog header and only include references to files.\n";
        return 1;
    }

    if ($checkWebKitStyle) {
        print STDERR "  Running check-webkit-style.\n  ";
        system "$FindBin::Bin/check-webkit-style";
    }

    die "--git-commit and --git-index are incompatible when not used with --only-files." if ($gitIndex && $gitCommit && !$onlyFiles);

    isSVN() || isGit() || die "Couldn't determine your version control system.";

    my %paths = processPaths(@ARGV);

    # Find the list of modified files
    my ($changedFiles, $conflictFiles, $functionLists, $addedRegressionTests, $requiresTests) = generateFileList(%paths, $gitCommit, $gitIndex, $mergeBase, %attributeCache);

    if (!@$changedFiles && !@$conflictFiles && !keys %$functionLists) {
        print STDERR "  No changes found.\n";
        return 1;
    }

    if (@$conflictFiles) {
        print STDERR "  The following files have conflicts. Run prepare-ChangeLog again after fixing the conflicts:\n";
        print STDERR join("\n", @$conflictFiles), "\n";
        return 1;
    }

    generateFunctionLists($changedFiles, $functionLists, $gitCommit, $gitIndex, $mergeBase);

    # Get some parameters for the ChangeLog we are about to write.
    $name = changeLogNameFromArgs($name, $gitCommit);
    $emailAddress = changeLogEmailAddressFromArgs($emailAddress, $gitCommit);

    print STDERR "  Change author: $name <$emailAddress>.\n";

    # Remove trailing parenthesized notes from user name (bit of hack).
    $name =~ s/\(.*?\)\s*$//g;

    my $bugURL;
    if ($bugNumber) {
        $bugURL = "https://bugs.webkit.org/show_bug.cgi?id=$bugNumber";
    }

    if ($bugNumber && !$bugDescription) {
        my $bugXMLData = fetchBugXMLData($bugURL, $bugNumber);
        $bugDescription = fetchBugDescriptionFromBugXMLData($bugURL, $bugNumber, $bugXMLData);
        $bugRadarURL = fetchRadarURLFromBugXMLData($bugNumber, $bugXMLData);
    }

    my ($filesInChangeLog, $prefixes) = findChangeLogs($functionLists, $writeChangeLogs);

    # Get the latest ChangeLog files from svn.
    my $changeLogs = getLatestChangeLogs($prefixes);

    if (@$changeLogs && $updateChangeLogs && isSVN()) {
        resolveConflictedChangeLogs($changeLogs);
    }

    generateNewChangeLogs($prefixes, $filesInChangeLog, $addedRegressionTests, $requiresTests, $functionLists, $bugURL, $bugDescription, $bugRadarURL, $name, $emailAddress, $gitReviewer, $gitCommit, $writeChangeLogs, $delimiters, $onlyFiles);

    if ($writeChangeLogs) {
        print STDERR "-- Please remember to include a detailed description in your ChangeLog entry. --\n-- See <http://webkit.org/coding/contributing.html> for more info --\n";
    }

    # Write out another diff.
    if ($spewDiff && @$changedFiles) {
        printDiff($changedFiles, $gitCommit, $gitIndex, $mergeBase);
    }

    # Open ChangeLogs.
    if ($openChangeLogs && @$changeLogs) {
        openChangeLogs($changeLogs);
    }
    return 0;
}

sub originalFile($$$$)
{
    my ($file, $gitCommit, $gitIndex, $mergeBase) = @_;

    my $command;
    if (isSVN()) {
        my $escapedPathsString = escapeSubversionPath($file);
        $command = SVN . " cat $escapedPathsString";
    } elsif (isGit()) {
        $command = GIT . " show ";
        if ($gitCommit) {
            $command .= "$gitCommit^";
        } elsif ($mergeBase) {
            $command .= "$mergeBase";
        } else {
            $command .= "HEAD";
        }
        $command .= ":'$file'";
    }

    return $command;
}

sub generateFunctionLists($$$$$)
{
    my ($changedFiles, $functionLists, $gitCommit, $gitIndex, $mergeBase) = @_;
    my %delegateHash = (
        openDiff => sub ($$$$) {
            my ($changedFiles, $gitCommit, $gitIndex, $mergeBase) = @_;
            return unless open(DIFF, "-|", diffCommand($changedFiles, $gitCommit, $gitIndex, $mergeBase));
            return \*DIFF;
        },
        openFile => sub ($) {
            my ($file) = @_;
            if (isGit() && $gitCommit && !$gitIndex) {
                my $command = GIT . " show " . "$gitCommit" . ":'$file'";
                return unless open(SOURCE, "-|", $command);
            } else {
                return unless open(SOURCE, "<", $file);
            }
            return \*SOURCE;
        },
        openOriginalFile => sub ($) {
            my ($file, $gitCommit, $gitIndex, $mergeBase) = @_;
            return unless open(SOURCE, "-|", originalFile($file, $gitCommit, $gitIndex, $mergeBase));
            return \*SOURCE;
        },
        normalizePath => sub ($) {
            my ($path) = @_;
            return normalizePath(makeFilePathRelative($path));
        },
    );
    actuallyGenerateFunctionLists($changedFiles, $functionLists, $gitCommit, $gitIndex, $mergeBase, \%delegateHash);
}

sub changeLogDate($)
{
    my ($timeZone) = @_;
    my $savedTimeZone = $ENV{'TZ'};
    # Set TZ temporarily so that localtime() is in that time zone
    $ENV{'TZ'} = $timeZone;
    my $date = strftime("%Y-%m-%d", localtime());
    if (defined $savedTimeZone) {
         $ENV{'TZ'} = $savedTimeZone;
    } else {
         delete $ENV{'TZ'};
    }
    return $date;
}

sub changeLogNameFromArgs($$)
{
    my ($nameFromArgs, $gitCommit) = @_;
    # Silently allow --git-commit to win, we could warn if $nameFromArgs is defined.
    my $command = GIT . ' log --max-count=1 --pretty="format:%an" "' . $gitCommit . '"';
    return `$command` if $gitCommit;

    return $nameFromArgs || changeLogName();
}

sub changeLogEmailAddressFromArgs($$)
{
    my ($emailAddressFromArgs, $gitCommit) = @_;
    # Silently allow --git-commit to win, we could warn if $emailAddressFromArgs is defined.
    my $command = GIT . ' log --max-count=1 --pretty="format:%ae" "' . $gitCommit . '"';
    return `$command` if $gitCommit;

    return $emailAddressFromArgs || changeLogEmailAddress();
}

sub fetchBugXMLData($$)
{
    my ($bugURL, $bugNumber) = @_;

    my $bugXMLURL = "$bugURL&ctype=xml&excludefield=attachmentdata";
    # Perl has no built in XML processing, so we'll fetch and parse with curl and grep
    # Pass --insecure because some cygwin installs have no certs we don't
    # care about validating that bugs.webkit.org is who it says it is here.
    my $xmlData = `curl --insecure --silent "$bugXMLURL"`;
    if ($xmlData !~ /<\?xml/) {
        # Maybe the reason the above did not work is because the curl that is installed doesn't
        # support ssl at all.
        if (`curl --version | grep ^Protocols` !~ /\bhttps\b/) {
            print STDERR "  Could not get description for bug $bugNumber.\n";
            print STDERR "  It looks like your version of curl does not support ssl.\n";
            print STDERR "  If you are using macports, this can be fixed with sudo port install curl +ssl.\n";
        }
        exit 1;
    }
    return $xmlData;
}

sub findChangeLogs($$)
{
    my ($functionLists, $requireChangeLogToExist) = @_;

    # Find the change logs.
    my %has_log;
    my %filesInChangeLog;
    foreach my $file (sort keys %$functionLists) {
        my $prefix = $file;
        my $has_log = 0;
        while ($prefix) {
            if ($^O eq "MSWin32") {
                $prefix =~ s-\\[^\\]+\\?$-\\- or $prefix = "";
            } else {
                $prefix =~ s-/[^/]+/?$-/- or $prefix = "";
            }
            $has_log = $has_log{$prefix};
            if (!defined $has_log) {
                $has_log = -f "${prefix}ChangeLog";
                $has_log{$prefix} = $has_log;
            }
            last if $has_log;
        }
        if (!$has_log && $requireChangeLogToExist) {
            print STDERR "No ChangeLog found for $file.\n";
        } else {
            push @{$filesInChangeLog{$prefix}}, $file;
        }
    }

    # Build the list of ChangeLog prefixes in the correct project order
    my @prefixes;
    my %prefixesSort;
    foreach my $prefix (keys %filesInChangeLog) {
        my $prefixDir = substr($prefix, 0, length($prefix) - 1); # strip trailing /
        my $sortKey = lc $prefix;
        $sortKey = "top level" unless length $sortKey;

        if ($prefixDir eq "top level") {
            $sortKey = "";
        } elsif ($prefixDir eq "Tools") {
            $sortKey = "-, just after top level";
        } elsif ($prefixDir eq "WebBrowser") {
            $sortKey = lc "WebKit, WebBrowser after";
        } elsif ($prefixDir eq "Source/WebCore") {
            $sortKey = lc "WebFoundation, WebCore after";
        } elsif ($prefixDir eq "LayoutTests") {
            $sortKey = lc "~, LayoutTests last";
        }

        $prefixesSort{$sortKey} = $prefix;
    }
    foreach my $prefixSort (sort keys %prefixesSort) {
        push @prefixes, $prefixesSort{$prefixSort};
    }
    return (\%filesInChangeLog, \@prefixes);
}

sub getLatestChangeLogs($)
{
    my ($prefixes) = @_;

    my @changeLogs = ();
    foreach my $prefix (@$prefixes) {
        push @changeLogs, File::Spec->catfile($prefix || ".", "ChangeLog");
    }
    return \@changeLogs;
}

sub svnUpdateCommand(@)
{
    my @changeLogs = shift;

    my @escapedChangeLogPaths = map(escapeSubversionPath($_), @changeLogs);
    my $escapedChangeLogPathsString = qq(") . join(qq(" "), @escapedChangeLogPaths) . qq(");
    my $command = SVN . " update $escapedChangeLogPathsString";

    return $command;
}

sub resolveChangeLogsPath($@)
{
    my ($resolveChangeLogsPath, @conflictedChangeLogs) = @_;

    my @escapedConflictedChangeLogs = map(escapeSubversionPath($_), @conflictedChangeLogs);
    my $escapedConflictedChangeLogsString = qq(") . join(qq(" "), @escapedConflictedChangeLogs) . qq(");
    my $command = "$resolveChangeLogsPath --no-warnings $escapedConflictedChangeLogsString";

    return $command;
}

sub resolveConflictedChangeLogs($)
{
    my ($changeLogs) = @_;

    print STDERR "  Running 'svn update' to update ChangeLog files.\n";
    open ERRORS, "-|", svnUpdateCommand(@$changeLogs)
        or die "The svn update of ChangeLog files failed: $!.\n";
    my @conflictedChangeLogs;
    while (my $line = <ERRORS>) {
        print STDERR "    ", $line;
        push @conflictedChangeLogs, $1 if $line =~ m/^C\s+(.+?)[\r\n]*$/;
    }
    close ERRORS;

    return if !@conflictedChangeLogs;

    print STDERR "  Attempting to merge conflicted ChangeLogs.\n";
    my $resolveChangeLogsPath = File::Spec->catfile(dirname($0), "resolve-ChangeLogs");
    open RESOLVE, "-|", resolveChangeLogsPath($resolveChangeLogsPath, @conflictedChangeLogs)
        or die "Could not open resolve-ChangeLogs script: $!.\n";
    print STDERR "    $_" while <RESOLVE>;
    close RESOLVE;
}

sub generateNewChangeLogs($$$$$$$$$$$$$$$)
{
    my ($prefixes, $filesInChangeLog, $addedRegressionTests, $requiresTests, $functionLists, $bugURL, $bugDescription, $bugRadarURL, $name, $emailAddress, $gitReviewer, $gitCommit, $writeChangeLogs, $delimiters, $onlyFiles) = @_;

    my $hasWebCoreChange = 0;
    foreach my $prefix (@$prefixes) {
        if (unixPath($prefix) =~ m|/WebCore/$|) {
            $hasWebCoreChange = 1;
        }
    }

    # Generate new ChangeLog entries and (optionally) write out new ChangeLog files.
    foreach my $prefix (@$prefixes) {
        my $endl = "\n";
        my @old_change_log;

        if ($writeChangeLogs) {
            my $changeLogPath = File::Spec->catfile($prefix || ".", "ChangeLog");
            print STDERR "  Editing the ${changeLogPath} file.\n";
            open OLD_CHANGE_LOG, ${changeLogPath} or die "Could not open ${changeLogPath} file: $!.\n";
            # It's less efficient to read the whole thing into memory than it would be
            # to read it while we prepend to it later, but I like doing this part first.
            @old_change_log = <OLD_CHANGE_LOG>;
            close OLD_CHANGE_LOG;
            # We want to match the ChangeLog's line endings in case it doesn't match
            # the native line endings for this version of perl.
            if ($old_change_log[0] =~ /(\r?\n)$/g) {
                $endl = "$1";
            }
            open CHANGE_LOG, "> ${changeLogPath}" or die "Could not write ${changeLogPath}\n.";
            binmode(CHANGE_LOG);
        } else {
            open CHANGE_LOG, ">-" or die "Could not write to STDOUT\n.";
            print substr($prefix, 0, length($prefix) - 1) . ":\n\n" unless (scalar @$prefixes) == 1 && !$delimiters;
        }

        if (!$onlyFiles) {
            my $date = changeLogDate(ChangeLogTimeZone);
            print CHANGE_LOG normalizeLineEndings("$date  $name  <$emailAddress>\n\n", $endl);
        }

        my ($reviewer, $description) = reviewerAndDescriptionForGitCommit($gitCommit, $gitReviewer) if $gitCommit;
        $reviewer = "NOBODY (OO" . "PS!)" if !$reviewer;

        ($bugDescription, $description) =
            ($description =~ /^(?:\s*(.*)\n)?(?:\s*\n)*((?:\n|.)*)/)
            if !$bugDescription && $description;

        $bugDescription = "Need a short description (OOPS!)." unless $bugDescription;
        $bugURL = "Need the bug URL (OOPS!)." unless $bugURL;

        if (!$onlyFiles) {
            print CHANGE_LOG normalizeLineEndings("        $bugDescription\n", $endl) if $bugDescription;
            print CHANGE_LOG normalizeLineEndings("        $bugURL\n", $endl) if $bugURL;
            print CHANGE_LOG normalizeLineEndings("        $bugRadarURL\n", $endl) if $bugRadarURL;
            print CHANGE_LOG normalizeLineEndings("\n", $endl);

            print CHANGE_LOG normalizeLineEndings("        Reviewed by $reviewer.\n\n", $endl);
            print CHANGE_LOG normalizeLineEndings($description . "\n", $endl) if $description;
        }

        my $shouldMentionTests = @$requiresTests;
        $shouldMentionTests |= !$hasWebCoreChange && unixPath($prefix) =~ m|/WebKit/$|;
        $shouldMentionTests |= unixPath($prefix) =~ m|/WebCore/$|;

        if ($shouldMentionTests) {
            if (@$addedRegressionTests) {
                print CHANGE_LOG normalizeLineEndings(testListForChangeLog(sort @$addedRegressionTests), $endl);
            } else {
                print CHANGE_LOG normalizeLineEndings("        No new tests (OOPS!).\n\n", $endl);
            }
        }

        foreach my $file (sort @{$filesInChangeLog->{$prefix}}) {
            my $file_stem = substr $file, length $prefix;
            $file_stem = unixPath($file_stem);
            print CHANGE_LOG normalizeLineEndings("        * $file_stem:$functionLists->{$file}\n", $endl);
        }

        if ($writeChangeLogs) {
            print CHANGE_LOG normalizeLineEndings("\n", $endl), @old_change_log;
        } else {
            print CHANGE_LOG "\n";
            print "~\n"  if $delimiters;
        }

        close CHANGE_LOG;
    }
}

sub printDiff($$$$)
{
    my ($changedFiles, $gitCommit, $gitIndex, $mergeBase) = @_;

    print STDERR "  Running diff to help you write the ChangeLog entries.\n";
    local $/ = undef; # local slurp mode
    my $changedFilesString = "'" . join("' '", @$changedFiles) . "'";
    open DIFF, "-|", createPatchCommand($changedFilesString, $gitCommit, $gitIndex, $mergeBase) or die "The diff failed: $!.\n";
    print <DIFF>;
    close DIFF;
}

sub openChangeLogs($)
{
    my ($changeLogs) = @_;

    print STDERR "  Opening the edited ChangeLog files.\n";
    my $editor = $ENV{CHANGE_LOG_EDITOR} || $ENV{VISUAL} || $ENV{EDITOR};
    if ($editor) {
        system ((split ' ', $editor), @$changeLogs);
    } else {
        $editor = $ENV{CHANGE_LOG_EDIT_APPLICATION};
        if ($editor) {
            system "open", "-a", $editor, @$changeLogs;
        } else {
            system "open", "-e", @$changeLogs;
        }
    }
}

sub method_decl_to_selector($)
{
    (my $method_decl) = @_;

    $_ = $method_decl;

    if ((my $comment_stripped) = m-([^/]*)(//|/*).*-) {
        $_ = $comment_stripped;
    }

    s/,\s*...//;

    # Strip out the return type and parameter types. The extra )? takes care of most block parameter types.
    s/\([^\)]*\)\)?//g;

    if (/:/) {
        my @components = split /:/;
        pop @components if (scalar @components > 1);
        $_ = (join ':', map {s/.*[^[:word:]]//; scalar $_;} @components) . ':';
    } else {
        s/\s*$//;
        s/.*[^[:word:]]//;
    }

    return $_;
}

sub processPaths(\@)
{
    my ($paths) = @_;
    return ("." => 1) if (!@{$paths});

    my %result = ();

    for my $file (@{$paths}) {
        die "can't handle absolute paths like \"$file\"\n" if File::Spec->file_name_is_absolute($file);
        die "can't handle empty string path\n" if $file eq "";
        die "can't handle path with single quote in the name like \"$file\"\n" if $file =~ /'/; # ' (keep Xcode syntax highlighting happy)

        my $untouchedFile = $file;

        $file = canonicalizePath($file);

        die "can't handle paths with .. like \"$untouchedFile\"\n" if $file =~ m|/\.\./|;

        $result{$file} = 1;
    }

    return ("." => 1) if ($result{"."});

    # Remove any paths that also have a parent listed.
    for my $path (keys %result) {
        for (my $parent = dirname($path); $parent ne '.'; $parent = dirname($parent)) {
            if ($result{$parent}) {
                delete $result{$path};
                last;
            }
        }
    }

    return %result;
}

sub diffFromToString($$$)
{
    my ($gitCommit, $gitIndex, $mergeBase) = @_;

    return "" if isSVN();
    return $gitCommit if $gitCommit =~ m/.+\.\..+/;
    return "--cached \"$gitCommit^\"" if $gitCommit && $gitIndex;
    return "\"$gitCommit^\" \"$gitCommit\"" if $gitCommit;
    return "--cached" if $gitIndex;
    return $mergeBase if $mergeBase;
    return "HEAD" if isGit();
}

sub diffCommand($$$$)
{
    my ($paths, $gitCommit, $gitIndex, $mergeBase) = @_;

    # The function overlap detection logic in webkitperl::changelog::computeModifiedFunctions()
    # assumes that its line ranges were from a unified diff without any context lines.
    my $command;
    if (isSVN()) {
        my @escapedPaths = map(escapeSubversionPath($_), @$paths);
        my $escapedPathsString = qq(") . join(qq(" "), @escapedPaths) . qq(");
        $command = SVN . " diff --diff-cmd diff -x -U0 $escapedPathsString";
    } elsif (isGit()) {
        my $pathsString = "'" . join("' '", @$paths) . "'"; 
        $command = GIT . " diff --no-ext-diff -U0 " . diffFromToString($gitCommit, $gitIndex, $mergeBase);
        $command .= " -- $pathsString" unless $gitCommit or $mergeBase;
    }

    return $command;
}

sub statusCommand($$$$)
{
    my ($paths, $gitCommit, $gitIndex, $mergeBase) = @_;

    my $command;
    if (isSVN()) {
        my @escapedFiles = map(escapeSubversionPath($_), keys %$paths);
        my $escapedFilesString = qq(") . join(qq(" "), @escapedFiles) . qq(");
        $command = SVN . " stat $escapedFilesString";
    } elsif (isGit()) {
        my $filesString = '"' . join('" "', keys %$paths) . '"';
        $command = GIT . " diff -r --name-status -M -C " . diffFromToString($gitCommit, $gitIndex, $mergeBase);
        $command .= " -- $filesString" unless $gitCommit;
    }

    return "$command 2>&1";
}

sub createPatchCommand($$$$)
{
    my ($changedFilesString, $gitCommit, $gitIndex, $mergeBase) = @_;

    my $command;
    if (isSVN()) {
        $command = "'$FindBin::Bin/svn-create-patch --no-style' $changedFilesString";
    } elsif (isGit()) {
        $command = GIT . " diff -M -C " . diffFromToString($gitCommit, $gitIndex, $mergeBase);
        $command .= " -- $changedFilesString" unless $gitCommit;
    }

    return $command;
}

sub findOriginalFileFromSvn($)
{
    my ($file) = @_;
    my $baseUrl;
    open INFO, SVN . " info . |" or die;
    while (<INFO>) {
        if (/^URL: (.+?)[\r\n]*$/) {
            $baseUrl = $1;
        }
    }
    close INFO;
    my $sourceFile;
    my $escapedFile = escapeSubversionPath($file);
    open INFO, SVN . " info '$escapedFile' |" or die;
    while (<INFO>) {
        if (/^Copied From URL: (.+?)[\r\n]*$/) {
            $sourceFile = File::Spec->abs2rel($1, $baseUrl);
        }
    }
    close INFO;
    return $sourceFile;
}

sub determinePropertyChanges($$$)
{
    my ($file, $isAdd, $original) = @_;

    my $escapedFile = escapeSubversionPath($file);
    my %changes;
    if ($isAdd) {
        my %addedProperties;
        my %removedProperties;
        open PROPLIST, SVN . " proplist '$escapedFile' |" or die;
        while (<PROPLIST>) {
            $addedProperties{$1} = 1 if /^  (.+?)[\r\n]*$/ && $1 ne 'svn:mergeinfo';
        }
        close PROPLIST;
        if ($original) {
            my $escapedOriginal = escapeSubversionPath($original);
            open PROPLIST, SVN . " proplist '$escapedOriginal' |" or die;
            while (<PROPLIST>) {
                next unless /^  (.+?)[\r\n]*$/;
                my $property = $1;
                if (exists $addedProperties{$property}) {
                    delete $addedProperties{$1};
                } else {
                    $removedProperties{$1} = 1;
                }
            }
        }
        $changes{"A"} = [sort keys %addedProperties] if %addedProperties;
        $changes{"D"} = [sort keys %removedProperties] if %removedProperties;
    } else {
        open DIFF, SVN . " diff '$escapedFile' |" or die;
        while (<DIFF>) {
            if (/^Property changes on:/) {
                while (<DIFF>) {
                    my $operation;
                    my $property;
                    if (/^Added: (\S*)/) {
                        $operation = "A";
                        $property = $1;
                    } elsif (/^Modified: (\S*)/) {
                        $operation = "M";
                        $property = $1;
                    } elsif (/^Deleted: (\S*)/) {
                        $operation = "D";
                        $property = $1;
                    } elsif (/^Name: (\S*)/) {
                        # Older versions of svn just say "Name" instead of the type
                        # of property change.
                        $operation = "C";
                        $property = $1;
                    }
                    if ($operation) {
                        $changes{$operation} = [] unless exists $changes{$operation};
                        push @{$changes{$operation}}, $property;
                    }
                }
            }
        }
        close DIFF;
    }
    return \%changes;
}

sub pluralizeAndList($$@)
{
    my ($singular, $plural, @items) = @_;

    return if @items == 0;
    return "$singular $items[0]" if @items == 1;
    return "$plural " . join(", ", @items[0 .. $#items - 1]) . " and " . $items[-1];
}

sub generateFileList(\%$$$\%)
{
    my ($paths, $gitCommit, $gitIndex, $mergeBase, $attributeCache) = @_;

    my @changedFiles;
    my @conflictFiles;
    my %functionLists;
    my @addedRegressionTests;
    my @requiresTests;
    print STDERR "  Running status to find changed, added, or removed files.\n";
    open STAT, "-|", statusCommand($paths, $gitCommit, $gitIndex, $mergeBase) or die "The status failed: $!.\n";
    while (<STAT>) {
        my $status;
        my $propertyStatus;
        my $propertyChanges;
        my $original;
        my $file;

        if (isSVN()) {
            my $matches;
            if (isSVNVersion16OrNewer()) {
                $matches = /^([ ACDMR])([ CM]).{5} (.+?)[\r\n]*$/;
                $status = $1;
                $propertyStatus = $2;
                $file = $3;
            } else {
                $matches = /^([ ACDMR])([ CM]).{4} (.+?)[\r\n]*$/;
                $status = $1;
                $propertyStatus = $2;
                $file = $3;
            }
            if ($matches) {
                $file = normalizePath($file);
                $original = findOriginalFileFromSvn($file) if substr($_, 3, 1) eq "+";
                my $isAdd = isAddedStatus($status);
                $propertyChanges = determinePropertyChanges($file, $isAdd, $original) if isModifiedStatus($propertyStatus) || $isAdd;
            } else {
                print;  # error output from svn stat
            }
        } elsif (isGit()) {
            if (/^([ADM])\t(.+)$/) {
                $status = $1;
                $propertyStatus = " ";  # git doesn't have properties
                $file = normalizePath($2);
            } elsif (/^([CR])[0-9]{1,3}\t([^\t]+)\t([^\t\n]+)$/) { # for example: R90%    newfile    oldfile
                $status = $1;
                $propertyStatus = " ";
                $original = normalizePath($2);
                $file = normalizePath($3);
            } else {
                print;  # error output from git diff
            }
        }

        next if !$status || isUnmodifiedStatus($status) && isUnmodifiedStatus($propertyStatus);

        $file = makeFilePathRelative($file);

        if (isModifiedStatus($status) || isAddedStatus($status) || isModifiedStatus($propertyStatus)) {
            my @components = File::Spec->splitdir($file);
            if ($components[0] eq "LayoutTests") {
                push @addedRegressionTests, $file
                    if isAddedStatus($status)
                       && $file =~ /\.([a-zA-Z]+)$/
                       && SupportedTestExtensions->{lc($1)}
                       && $file !~ /-expected(-mismatch)?\.html$/
                       && !scalar(grep(/^resources$/i, @components))
                       && !scalar(grep(/^script-tests$/i, @components));
            } elsif (attributeCommand($attributeCache, $file, "test")) {
                push @addedRegressionTests, $file;
            } elsif (attributeCommand($attributeCache, $file, "requiresTests")) {
                push @requiresTests, $file
            }
            push @changedFiles, $file if $components[$#components] ne "ChangeLog";
        } elsif (isConflictStatus($status, $gitCommit, $gitIndex) || isConflictStatus($propertyStatus, $gitCommit, $gitIndex)) {
            push @conflictFiles, $file;
        }
        if (basename($file) ne "ChangeLog") {
            my $description = statusDescription($status, $propertyStatus, $original, $propertyChanges);
            $functionLists{$file} = $description if defined $description;
        }
    }
    close STAT;
    return (\@changedFiles, \@conflictFiles, \%functionLists, \@addedRegressionTests, \@requiresTests);
}

sub isUnmodifiedStatus($)
{
    my ($status) = @_;

    my %statusCodes = (
        " " => 1,
    );

    return $statusCodes{$status};
}

sub isModifiedStatus($)
{
    my ($status) = @_;

    my %statusCodes = (
        "M" => 1,
    );

    return $statusCodes{$status};
}

sub isAddedStatus($)
{
    my ($status) = @_;

    my %statusCodes = (
        "A" => 1,
        "C" => isGit(),
        "R" => 1,
    );

    return $statusCodes{$status};
}

sub isConflictStatus($$$)
{
    my ($status, $gitCommit, $gitIndex) = @_;

    my %svn = (
        "C" => 1,
    );

    my %git = (
        "U" => 1,
    );

    return 0 if ($gitCommit || $gitIndex); # an existing commit or staged change cannot have conflicts
    return $svn{$status} if isSVN();
    return $git{$status} if isGit();
}

sub statusDescription($$$$)
{
    my ($status, $propertyStatus, $original, $propertyChanges) = @_;

    my $propertyDescription = defined $propertyChanges ? propertyChangeDescription($propertyChanges) : "";

    my %svn = (
        "A" => defined $original ? sprintf(" Copied from \%s.", $original) : " Added.",
        "D" => " Removed.",
        "M" => "",
        "R" => defined $original ? sprintf(" Replaced with \%s.", $original) : " Replaced.",
        " " => "",
    );

    my %git = %svn;
    $git{"A"} = " Added.";
    if (defined $original) {
        $git{"C"} = sprintf(" Copied from \%s.", $original);
        $git{"R"} = sprintf(" Renamed from \%s.", $original);
    }

    my $description;
    $description = $svn{$status} if isSVN() && exists $svn{$status};
    $description = $git{$status} if isGit() && exists $git{$status};
    return unless defined $description;

    $description .= $propertyDescription unless isAddedStatus($status);
    return $description;
}

sub propertyChangeDescription($)
{
    my ($propertyChanges) = @_;

    my %operations = (
        "A" => "Added",
        "M" => "Modified",
        "D" => "Removed",
        "C" => "Changed",
    );

    my $description = "";
    while (my ($operation, $properties) = each %$propertyChanges) {
        my $word = $operations{$operation};
        my $list = pluralizeAndList("property", "properties", @$properties);
        $description .= " $word $list.";
    }
    return $description;
}

sub testListForChangeLog(@)
{
    my (@tests) = @_;

    return "" unless @tests;

    my $leadString = "        Test" . (@tests == 1 ? "" : "s") . ": ";
    my $list = $leadString;
    foreach my $i (0..$#tests) {
        $list .= " " x length($leadString) if $i;
        my $test = $tests[$i];
        $test =~ s/^LayoutTests\///;
        $list .= "$test\n";
    }
    $list .= "\n";

    return $list;
}

sub reviewerAndDescriptionForGitCommit($$)
{
    my ($commit, $gitReviewer) = @_;

    my $description = '';
    my $reviewer;

    my @args = qw(rev-list --pretty);
    push @args, '-1' if $commit !~ m/.+\.\..+/;
    my $gitLog;
    {
        local $/ = undef;
        open(GITLOG, "-|", GIT, @args, $commit) || die;
        $gitLog = <GITLOG>;
        close(GITLOG);
    }

    my @commitLogs = split(/^[Cc]ommit [a-f0-9]{40}/m, $gitLog);
    shift @commitLogs; # Remove initial blank commit log
    my $commitLogCount = 0;
    foreach my $commitLog (@commitLogs) {
        $description .= "\n" if $commitLogCount;
        $commitLogCount++;
        my $inHeader = 1;
        my $commitLogIndent; 
        my @lines = split(/\n/, $commitLog);
        shift @lines; # Remove initial blank line
        foreach my $line (@lines) {
            if ($inHeader) {
                if (!$line) {
                    $inHeader = 0;
                }
                next;
            } elsif ($line =~ /[Ss]igned-[Oo]ff-[Bb]y: (.+)/) {
                if (!$reviewer) {
                    $reviewer = $1;
                } else {
                    $reviewer .= ", " . $1;
                }
            } elsif ($line =~ /^\s*$/) {
                $description = $description . "\n";
            } else {
                if (!defined($commitLogIndent)) {
                    # Let the first line with non-white space determine
                    # the global indent.
                    $line =~ /^(\s*)\S/;
                    $commitLogIndent = length($1);
                }
                # Strip at most the indent to preserve relative indents.
                $line =~ s/^\s{0,$commitLogIndent}//;
                $description = $description . (" " x 8) . $line . "\n";
            }
        }
    }
    if (!$reviewer) {
      $reviewer = $gitReviewer;
    }

    return ($reviewer, $description);
}

sub normalizeLineEndings($$)
{
    my ($string, $endl) = @_;
    $string =~ s/\r?\n/$endl/g;
    return $string;
}
