diff --git a/.gitignore b/.gitignore
index 5502cca..fdabb39 100644
--- a/.gitignore
+++ b/.gitignore
@@ -63,6 +63,7 @@
 /third_party/qemu-linux-x64
 /third_party/qemu-mac-x64
 /third_party/r8/lib
+third_party/r8/*.jar
 /third_party/rapidjson/src
 /third_party/requests/src
 /third_party/six
diff --git a/include/platform/FeaturesMtl.h b/include/platform/FeaturesMtl.h
index 7d9aec2..165bb47 100644
--- a/include/platform/FeaturesMtl.h
+++ b/include/platform/FeaturesMtl.h
@@ -21,11 +21,6 @@ struct FeaturesMtl : FeatureSetBase
         "has_base_vertex_instanced_draw", FeatureCategory::MetalFeatures,
         "The renderer supports base vertex instanced draw", &members};
 
-    // Support depth texture filtering
-    Feature hasDepthTextureFiltering = {
-        "has_depth_texture_filtering", FeatureCategory::MetalFeatures,
-        "The renderer supports depth texture's filtering other than nearest", &members};
-
     // Support explicit memory barrier
     Feature hasExplicitMemBarrier = {"has_explicit_mem_barrier_mtl", FeatureCategory::MetalFeatures,
                                      "The renderer supports explicit memory barrier", &members};
diff --git a/scripts/code_generation_hashes/Metal_format_table.json b/scripts/code_generation_hashes/Metal_format_table.json
index 66581aa..1a0cd0c 100644
--- a/scripts/code_generation_hashes/Metal_format_table.json
+++ b/scripts/code_generation_hashes/Metal_format_table.json
@@ -4,9 +4,9 @@
   "src/libANGLE/renderer/angle_format_map.json":
     "951e1bceaba86eecb5c23173e897d092",
   "src/libANGLE/renderer/metal/gen_mtl_format_table.py":
-    "e4d1d26c5be587141681e011529affbd",
+    "9de8b37dbac5ed93d5f88ad4f0d8ca42",
   "src/libANGLE/renderer/metal/mtl_format_map.json":
-    "9199f9f2cf9bd7eb218a2bba3a7c0177",
+    "04a80596b75c287f525dac9769219cb2",
   "src/libANGLE/renderer/metal/mtl_format_table_autogen.mm":
-    "b4de420f6a4c28239d736417a412006d"
+    "8217d0e32cce459b46b4fb1355c3984b"
 }
\ No newline at end of file
diff --git a/scripts/export_targets.py b/scripts/export_targets.py
index 309d405..8de997c 100755
--- a/scripts/export_targets.py
+++ b/scripts/export_targets.py
@@ -231,9 +231,9 @@ IGNORED_INCLUDES = {
     b'vulkan_xcb.h',
     b'vulkan_xlib.h',
     b'vulkan_xlib_xrandr.h',
-# rapidjson adds these include stubs into their documentation
-# comments. Since the script doesn't skip comments they are
-# erroneously marked as valid includes
+    # rapidjson adds these include stubs into their documentation
+    # comments. Since the script doesn't skip comments they are
+    # erroneously marked as valid includes
     b'rapidjson/...',
     # Validation layers support building with robin hood hashing, but we are not enabling that
     # See http://anglebug.com/5791
diff --git a/scripts/run_code_generation.py b/scripts/run_code_generation.py
index 9710b2e..c0a9a13 100755
--- a/scripts/run_code_generation.py
+++ b/scripts/run_code_generation.py
@@ -13,6 +13,7 @@ import os
 import subprocess
 import sys
 import platform
+import argparse
 
 script_dir = sys.path[0]
 root_dir = os.path.abspath(os.path.join(script_dir, '..'))
@@ -214,11 +215,31 @@ def main():
     all_new_hashes = {}
     any_dirty = False
 
-    verify_only = False
-    if len(sys.argv) > 1 and sys.argv[1] == '--verify-no-dirty':
-        verify_only = True
+    parser = argparse.ArgumentParser(description='Generate ANGLE internal code.')
+    parser.add_argument(
+        '-v',
+        '--verify-no-dirty',
+        dest='verify_only',
+        type=bool,
+        help='verify hashes are not dirty')
+    parser.add_argument(
+        '-g', '--generator', action='append', nargs='*', type=str, dest='specifiedGenerators'),
+
+    args = parser.parse_args()
+    filteredGenerators = args.specifiedGenerators[0]
+    verify_only = args.verify_only
+    ranGenerators = {}
+
+    if (filteredGenerators):
+        ranGenerators = {k: v for k, v in generators.items() if k in filteredGenerators}
+    else:
+        ranGenerators = generators
+
+    if (len(ranGenerators) == 0):
+        print("No valid generators specified.")
+        return -1
 
-    for name, script in sorted(generators.items()):
+    for name, script in sorted(ranGenerators.items()):
         info = auto_script(script)
         fname = get_hash_file_name(name)
         filenames = info['inputs'] + info['outputs'] + [script]
@@ -257,7 +278,7 @@ def main():
             sys.exit(1)
 
         # Update the output hashes again since they can be formatted.
-        for name, script in sorted(generators.items()):
+        for name, script in sorted(ranGenerators.items()):
             info = auto_script(script)
             fname = get_hash_file_name(name)
             update_output_hashes(name, info['outputs'], all_new_hashes[fname])
diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index ebe282c..758fb06 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index 4711774..9eab1b3 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/CodeGen.cpp b/src/compiler/translator/CodeGen.cpp
index 497ef88..47213c9 100644
--- a/src/compiler/translator/CodeGen.cpp
+++ b/src/compiler/translator/CodeGen.cpp
@@ -23,6 +23,9 @@
 #ifdef ANGLE_ENABLE_METAL
 #    include "compiler/translator/TranslatorMetalDirect.h"
 #endif  // ANGLE_ENABLE_METAL
+#ifdef ANGLE_ENABLE_METAL_SPIRV
+#    include "compiler/translator/TranslatorMetal.h"
+#endif  // ANGLE_ENABLE_METAL_SPIRV
 
 #ifdef ANGLE_ENABLE_METAL_SPIRV
 #    include "compiler/translator/TranslatorMetal.h"
diff --git a/src/compiler/translator/TranslatorMetal.cpp b/src/compiler/translator/TranslatorMetal.cpp
index 7ac4749..d25b72a 100644
--- a/src/compiler/translator/TranslatorMetal.cpp
+++ b/src/compiler/translator/TranslatorMetal.cpp
@@ -32,13 +32,6 @@
 namespace sh
 {
 
-namespace mtl
-{
-/** extern */
-const char kCoverageMaskEnabledConstName[]      = "ANGLECoverageMaskEnabled";
-const char kRasterizerDiscardEnabledConstName[] = "ANGLERasterizerDisabled";
-}  // namespace mtl
-
 namespace
 {
 
diff --git a/src/compiler/translator/TranslatorMetalConstantNames.cpp b/src/compiler/translator/TranslatorMetalConstantNames.cpp
new file mode 100644
index 0000000..515cc6e
--- /dev/null
+++ b/src/compiler/translator/TranslatorMetalConstantNames.cpp
@@ -0,0 +1,24 @@
+//
+// Copyright 2019 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// TranslatorMetalConstantNames:
+// Implementation of constant values used in both translator
+// backends.
+
+#include <stdio.h>
+
+#include "GLSLANG/ShaderLang.h"
+
+namespace sh
+{
+
+namespace mtl
+{
+/** extern */
+const char kCoverageMaskEnabledConstName[]      = "ANGLECoverageMaskEnabled";
+const char kRasterizerDiscardEnabledConstName[] = "ANGLERasterizerDisabled";
+}  // namespace mtl
+
+}  // namespace sh
diff --git a/src/compiler/translator/TranslatorMetalDirect.cpp b/src/compiler/translator/TranslatorMetalDirect.cpp
index 2e143ba..9da5ad2 100644
--- a/src/compiler/translator/TranslatorMetalDirect.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect.cpp
@@ -950,7 +950,6 @@ bool TranslatorMetalDirect::translateImpl(TInfoSinkBase &sink,
                 getSymbolTable().findBuiltIn(ImmutableString("gl_PointSize"), getShaderVersion()));
             DeclareRightBeforeMain(*root, *pointSize);
         }
-
         if (FindSymbolNode(root, BuiltInVariable::gl_VertexIndex()->name()))
         {
             if (!ReplaceVariable(this, root, BuiltInVariable::gl_VertexIndex(), &kgl_VertexIDMetal))
diff --git a/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp b/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp
index e13d6e7..f9bb4e9 100644
--- a/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp
@@ -1738,7 +1738,6 @@ void GenMetalTraverser::emitFunctionSignature(const TFunction &func)
         const TVariable &param = *func.getParam(i);
         emitFunctionParameter(func, param);
     }
-
     if (isTraversingVertexMain)
     {
         mOut << " @@XFB-Bindings@@ ";
diff --git a/src/compiler/translator/TranslatorMetalDirect/EnvironmentVariable.h b/src/compiler/translator/TranslatorMetalDirect/EnvironmentVariable.h
new file mode 100644
index 0000000..d823fc7
--- /dev/null
+++ b/src/compiler/translator/TranslatorMetalDirect/EnvironmentVariable.h
@@ -0,0 +1,45 @@
+//
+// Copyright 2020 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_ENVIRONMENTVARIABLE_H_
+#define COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_ENVIRONMENTVARIABLE_H_
+
+#include <cstdlib>
+#include <string>
+
+#include "common/debug.h"
+
+namespace sh
+{
+
+inline bool readBoolEnvVar(const char *var)
+{
+    const char *str = std::getenv(var);
+    if (str == nullptr)
+    {
+        return false;
+    }
+    if (strcmp(str, "0") == 0)
+    {
+        return false;
+    }
+    ASSERT(strcmp(str, "1") == 0);
+    return true;
+}
+
+inline std::string readStringEnvVar(const char *var)
+{
+    const char *str = std::getenv(var);
+    if (str == nullptr)
+    {
+        return "";
+    }
+    return str;
+}
+
+}  // namespace sh
+
+#endif  // COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_ENVIRONMENTVARIABLE_H_
diff --git a/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp b/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp
index 81ff272..9d2b43b 100644
--- a/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp
@@ -25,7 +25,7 @@ Name IdGen::createNewName(size_t count,
 {
     const unsigned id = mNext++;
     char idBuffer[std::numeric_limits<unsigned>::digits10 + 1];
-    sprintf(idBuffer, "%u", id);
+    snprintf(idBuffer, sizeof(idBuffer), "%u", id);
 
     mNewNameBuffer.clear();
     mNewNameBuffer += '_';
diff --git a/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp b/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp
index 7fe13a6..299a2f9 100644
--- a/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp
@@ -601,7 +601,7 @@ class ConvertStructState : angle::NonCopyable
     void pushNamePath(unsigned extra)
     {
         char buffer[std::numeric_limits<unsigned>::digits10 + 1];
-        sprintf(buffer, "%u", extra);
+        snprintf(buffer, sizeof(buffer), "%u", extra);
         pushNamePath(buffer);
     }
 
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 82837bf..2c580b5 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index d2eab0b..2ec2d2c 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,8 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of
+ * the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
index 55e2f8b..4237558 100644
--- a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
+++ b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
@@ -10,6 +10,7 @@
 #include "compiler/translator/tree_util/IntermNode_util.h"
 #include "compiler/translator/tree_util/IntermTraverse.h"
 
+#if defined(ANGLE_ENABLE_GLSL) && defined(ANGLE_ENABLE_APPLE_WORKAROUNDS)
 namespace sh
 {
 
@@ -70,5 +71,5 @@ bool UnfoldShortCircuitAST(TCompiler *compiler, TIntermBlock *root)
     root->traverse(&traverser);
     return traverser.updateTree(compiler, root);
 }
-
+#endif
 }  // namespace sh
diff --git a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
index ad3cc08..75069c5 100644
--- a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
+++ b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
@@ -11,7 +11,7 @@
 #define COMPILER_TRANSLATOR_TREEOPS_APPLE_UNFOLDSHORTCIRCUITAST_H_
 
 #include "common/angleutils.h"
-
+#include "common/debug.h"
 namespace sh
 {
 
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 1535a99..a6016d5 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
diff --git a/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.cpp b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.cpp
new file mode 100644
index 0000000..801e604
--- /dev/null
+++ b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.cpp
@@ -0,0 +1,81 @@
+//
+// Copyright 2021 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// ShaderInterfaceVariableInfoMap.cpp:
+//    Implements helper class for shader compilers
+//
+
+#include "libANGLE/renderer/ShaderInterfaceVariableInfoMap.h"
+namespace rx
+{
+
+const uint32_t ShaderInterfaceVariableInfo::kInvalid;
+
+ShaderInterfaceVariableInfo::ShaderInterfaceVariableInfo() {}
+
+// ShaderInterfaceVariableInfoMap implementation.
+ShaderInterfaceVariableInfoMap::ShaderInterfaceVariableInfoMap() = default;
+
+ShaderInterfaceVariableInfoMap::~ShaderInterfaceVariableInfoMap() = default;
+
+void ShaderInterfaceVariableInfoMap::clear()
+{
+    for (VariableNameToInfoMap &shaderMap : mData)
+    {
+        shaderMap.clear();
+    }
+}
+
+bool ShaderInterfaceVariableInfoMap::contains(gl::ShaderType shaderType,
+                                              const std::string &variableName) const
+{
+    return mData[shaderType].find(variableName) != mData[shaderType].end();
+}
+
+const ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(
+    gl::ShaderType shaderType,
+    const std::string &variableName) const
+{
+    auto it = mData[shaderType].find(variableName);
+    ASSERT(it != mData[shaderType].end());
+    return it->second;
+}
+
+ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(gl::ShaderType shaderType,
+                                                                 const std::string &variableName)
+{
+    auto it = mData[shaderType].find(variableName);
+    ASSERT(it != mData[shaderType].end());
+    return it->second;
+}
+
+void ShaderInterfaceVariableInfoMap::markAsDuplicate(gl::ShaderType shaderType,
+                                                     const std::string &variableName)
+{
+    ASSERT(contains(shaderType, variableName));
+    mData[shaderType][variableName].isDuplicate = true;
+}
+
+ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::add(gl::ShaderType shaderType,
+                                                                 const std::string &variableName)
+{
+    ASSERT(!contains(shaderType, variableName));
+    return mData[shaderType][variableName];
+}
+
+ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::addOrGet(
+    gl::ShaderType shaderType,
+    const std::string &variableName)
+{
+    return mData[shaderType][variableName];
+}
+
+ShaderInterfaceVariableInfoMap::Iterator ShaderInterfaceVariableInfoMap::getIterator(
+    gl::ShaderType shaderType) const
+{
+    return Iterator(mData[shaderType].begin(), mData[shaderType].end());
+}
+
+}  // namespace rx
diff --git a/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.h b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.h
new file mode 100644
index 0000000..851985a
--- /dev/null
+++ b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.h
@@ -0,0 +1,63 @@
+//
+// Copyright 2021 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// Header for the shared ShaderInterfaceVariableInfoMap class, used by both the
+// Metal and Direct Metal backends.
+#ifndef ShaderInterfaceVariableInfoMap_hpp
+#define ShaderInterfaceVariableInfoMap_hpp
+
+#include <functional>
+
+#include <stdio.h>
+#include "libANGLE/renderer/ProgramImpl.h"
+#include "libANGLE/renderer/glslang_wrapper_utils.h"
+#include "libANGLE/renderer/renderer_utils.h"
+namespace rx
+{
+
+// TODO: http://anglebug.com/4524: Need a different hash key than a string, since that's slow to
+// calculate.
+class ShaderInterfaceVariableInfoMap final : angle::NonCopyable
+{
+  public:
+    ShaderInterfaceVariableInfoMap();
+    ~ShaderInterfaceVariableInfoMap();
+
+    void clear();
+    bool contains(gl::ShaderType shaderType, const std::string &variableName) const;
+    const ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType,
+                                           const std::string &variableName) const;
+    ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType, const std::string &variableName);
+    ShaderInterfaceVariableInfo &add(gl::ShaderType shaderType, const std::string &variableName);
+    void markAsDuplicate(gl::ShaderType shaderType, const std::string &variableName);
+    ShaderInterfaceVariableInfo &addOrGet(gl::ShaderType shaderType,
+                                          const std::string &variableName);
+    size_t variableCount(gl::ShaderType shaderType) const { return mData[shaderType].size(); }
+
+    using VariableNameToInfoMap = angle::HashMap<std::string, ShaderInterfaceVariableInfo>;
+
+    class Iterator final
+    {
+      public:
+        Iterator(VariableNameToInfoMap::const_iterator beginIt,
+                 VariableNameToInfoMap::const_iterator endIt)
+            : mBeginIt(beginIt), mEndIt(endIt)
+        {}
+        VariableNameToInfoMap::const_iterator begin() { return mBeginIt; }
+        VariableNameToInfoMap::const_iterator end() { return mEndIt; }
+
+      private:
+        VariableNameToInfoMap::const_iterator mBeginIt;
+        VariableNameToInfoMap::const_iterator mEndIt;
+    };
+
+    Iterator getIterator(gl::ShaderType shaderType) const;
+
+  private:
+    gl::ShaderMap<VariableNameToInfoMap> mData;
+};
+
+}  // namespace rx
+#endif /* ShaderInterfaceVariableInfoMap_hpp */
diff --git a/src/libANGLE/renderer/gl/cgl/IOSurfaceSurfaceCGL.cpp b/src/libANGLE/renderer/gl/cgl/IOSurfaceSurfaceCGL.cpp
index a2b44d2..20ec85a 100644
--- a/src/libANGLE/renderer/gl/cgl/IOSurfaceSurfaceCGL.cpp
+++ b/src/libANGLE/renderer/gl/cgl/IOSurfaceSurfaceCGL.cpp
@@ -250,12 +250,10 @@ bool IOSurfaceSurfaceCGL::validateAttributes(EGLClientBuffer buffer,
         return false;
     }
 
-    // Check that the format matches this IOSurface plane
-    if (IOSurfaceGetBytesPerElementOfPlane(ioSurface, plane) !=
-        kIOSurfaceFormats[formatIndex].componentBytes)
-    {
-        return false;
-    }
+    // FIXME: Check that the format matches this IOSurface plane for pixel formats that we know of.
+    // We could map IOSurfaceGetPixelFormat to expected type plane and format type.
+    // However, the caller might supply us non-public pixel format, which makes exhaustive checks
+    // problematic.
 
     return true;
 }
diff --git a/src/libANGLE/renderer/glslang_wrapper_utils.cpp b/src/libANGLE/renderer/glslang_wrapper_utils.cpp
index ac1799c..91d8dc6 100644
--- a/src/libANGLE/renderer/glslang_wrapper_utils.cpp
+++ b/src/libANGLE/renderer/glslang_wrapper_utils.cpp
@@ -4683,72 +4683,6 @@ UniformBindingInfo::UniformBindingInfo(uint32_t bindingIndex,
 
 UniformBindingInfo::UniformBindingInfo() {}
 
-// ShaderInterfaceVariableInfo implementation.
-ShaderInterfaceVariableInfo::ShaderInterfaceVariableInfo() {}
-
-// ShaderInterfaceVariableInfoMap implementation.
-ShaderInterfaceVariableInfoMap::ShaderInterfaceVariableInfoMap() = default;
-
-ShaderInterfaceVariableInfoMap::~ShaderInterfaceVariableInfoMap() = default;
-
-void ShaderInterfaceVariableInfoMap::clear()
-{
-    for (VariableNameToInfoMap &shaderMap : mData)
-    {
-        shaderMap.clear();
-    }
-}
-
-bool ShaderInterfaceVariableInfoMap::contains(gl::ShaderType shaderType,
-                                              const std::string &variableName) const
-{
-    return mData[shaderType].find(variableName) != mData[shaderType].end();
-}
-
-const ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(
-    gl::ShaderType shaderType,
-    const std::string &variableName) const
-{
-    auto it = mData[shaderType].find(variableName);
-    ASSERT(it != mData[shaderType].end());
-    return it->second;
-}
-
-ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(gl::ShaderType shaderType,
-                                                                 const std::string &variableName)
-{
-    auto it = mData[shaderType].find(variableName);
-    ASSERT(it != mData[shaderType].end());
-    return it->second;
-}
-
-void ShaderInterfaceVariableInfoMap::markAsDuplicate(gl::ShaderType shaderType,
-                                                     const std::string &variableName)
-{
-    ASSERT(contains(shaderType, variableName));
-    mData[shaderType][variableName].isDuplicate = true;
-}
-
-ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::add(gl::ShaderType shaderType,
-                                                                 const std::string &variableName)
-{
-    ASSERT(!contains(shaderType, variableName));
-    return mData[shaderType][variableName];
-}
-
-ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::addOrGet(
-    gl::ShaderType shaderType,
-    const std::string &variableName)
-{
-    return mData[shaderType][variableName];
-}
-
-ShaderInterfaceVariableInfoMap::Iterator ShaderInterfaceVariableInfoMap::getIterator(
-    gl::ShaderType shaderType) const
-{
-    return Iterator(mData[shaderType].begin(), mData[shaderType].end());
-}
-
 // Strip indices from the name.  If there are non-zero indices, return false to indicate that this
 // image uniform doesn't require set/binding.  That is done on index 0.
 bool GetImageNameWithoutIndices(std::string *name)
diff --git a/src/libANGLE/renderer/glslang_wrapper_utils.h b/src/libANGLE/renderer/glslang_wrapper_utils.h
index 787193c..1a912a6 100644
--- a/src/libANGLE/renderer/glslang_wrapper_utils.h
+++ b/src/libANGLE/renderer/glslang_wrapper_utils.h
@@ -10,13 +10,13 @@
 #define LIBANGLE_RENDERER_GLSLANG_WRAPPER_UTILS_H_
 
 #include <functional>
-
-#include "common/spirv/spirv_types.h"
 #include "libANGLE/renderer/ProgramImpl.h"
 #include "libANGLE/renderer/renderer_utils.h"
 
 namespace rx
 {
+
+class ShaderInterfaceVariableInfoMap;
 constexpr gl::ShaderMap<const char *> kDefaultUniformNames = {
     {gl::ShaderType::Vertex, sh::vk::kDefaultUniformsNameVS},
     {gl::ShaderType::TessControl, sh::vk::kDefaultUniformsNameTCS},
@@ -136,48 +136,6 @@ struct ShaderInterfaceVariableInfo
     bool isDuplicate = false;
 };
 
-// TODO: http://anglebug.com/4524: Need a different hash key than a string, since that's slow to
-// calculate.
-class ShaderInterfaceVariableInfoMap final : angle::NonCopyable
-{
-  public:
-    ShaderInterfaceVariableInfoMap();
-    ~ShaderInterfaceVariableInfoMap();
-
-    void clear();
-    bool contains(gl::ShaderType shaderType, const std::string &variableName) const;
-    const ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType,
-                                           const std::string &variableName) const;
-    ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType, const std::string &variableName);
-    ShaderInterfaceVariableInfo &add(gl::ShaderType shaderType, const std::string &variableName);
-    void markAsDuplicate(gl::ShaderType shaderType, const std::string &variableName);
-    ShaderInterfaceVariableInfo &addOrGet(gl::ShaderType shaderType,
-                                          const std::string &variableName);
-    size_t variableCount(gl::ShaderType shaderType) const { return mData[shaderType].size(); }
-
-    using VariableNameToInfoMap = angle::HashMap<std::string, ShaderInterfaceVariableInfo>;
-
-    class Iterator final
-    {
-      public:
-        Iterator(VariableNameToInfoMap::const_iterator beginIt,
-                 VariableNameToInfoMap::const_iterator endIt)
-            : mBeginIt(beginIt), mEndIt(endIt)
-        {}
-        VariableNameToInfoMap::const_iterator begin() { return mBeginIt; }
-        VariableNameToInfoMap::const_iterator end() { return mEndIt; }
-
-      private:
-        VariableNameToInfoMap::const_iterator mBeginIt;
-        VariableNameToInfoMap::const_iterator mEndIt;
-    };
-
-    Iterator getIterator(gl::ShaderType shaderType) const;
-
-  private:
-    gl::ShaderMap<VariableNameToInfoMap> mData;
-};
-
 bool GetImageNameWithoutIndices(std::string *name);
 
 // Get the mapped sampler name.
@@ -199,7 +157,7 @@ void GlslangAssignTransformFeedbackLocations(gl::ShaderType shaderType,
                                              bool isTransformFeedbackStage,
                                              GlslangProgramInterfaceInfo *programInterfaceInfo,
                                              ShaderInterfaceVariableInfoMap *variableInfoMapOut);
-
+#if ANGLE_ENABLE_METAL_SPIRV
 // Retrieves the compiled SPIR-V code for each shader stage, and calls |GlslangAssignLocations|.
 void GlslangGetShaderSpirvCode(const GlslangSourceOptions &options,
                                const gl::ProgramState &programState,
@@ -210,8 +168,9 @@ void GlslangGetShaderSpirvCode(const GlslangSourceOptions &options,
 
 angle::Result GlslangTransformSpirvCode(const GlslangSpirvOptions &options,
                                         const ShaderInterfaceVariableInfoMap &variableInfoMap,
-                                        const angle::spirv::Blob &initialSpirvBlob,
+                                        const angle::qBlob &initialSpirvBlob,
                                         angle::spirv::Blob *spirvBlobOut);
+#endif
 
 }  // namespace rx
 
diff --git a/src/libANGLE/renderer/metal/BufferMtl.mm b/src/libANGLE/renderer/metal/BufferMtl.mm
index 279923f..900aea8 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.mm
+++ b/src/libANGLE/renderer/metal/BufferMtl.mm
@@ -365,7 +365,7 @@
     {
         if (buffer.offset == offset)
         {
-            return &buffer;
+            return static_cast<ConversionBufferMtl *>(&buffer);
         }
     }
 
@@ -520,7 +520,7 @@
         default:
             // dynamic buffer, allow up to 10 update per frame/encoding without
             // waiting for GPU.
-            if (adjustedSize <= mtl::kSharedMemBufferMaxBufSizeHint)
+            if (adjustedSize <= kConvertedElementArrayBufferInitialSize)
             {
                 maxBuffers = 10;
                 mBufferPool.setAlwaysUseSharedMem();
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index e5f4a82..39e5cd9 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -916,6 +916,7 @@ GLint GetOwnershipIdentity(const egl::AttributeMap &attribs)
 
     // Metal's blend state is set at once, while ANGLE tracks separate dirty
     // bits: ENABLED, FUNCS, and EQUATIONS. Merge all three of them to the first one.
+#if defined(ANGLE_IS_64_BIT_CPU)
     constexpr gl::State::DirtyBits checkBlendBitsMask(
         angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_ENABLED) |
         angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_FUNCS) |
@@ -924,6 +925,20 @@ GLint GetOwnershipIdentity(const egl::AttributeMap &attribs)
         angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_FUNCS) |
         angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_EQUATIONS));
 
+#else
+    gl::State::DirtyBits checkBlendBitsMask;
+    checkBlendBitsMask.set(
+        angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_ENABLED));
+    checkBlendBitsMask.set(
+        angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_FUNCS));
+    checkBlendBitsMask.set(
+        angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_EQUATIONS));
+    gl::State::DirtyBits resetBlendBitsMask;
+    resetBlendBitsMask.set(
+        angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_FUNCS));
+    resetBlendBitsMask.set(
+        angle::Bit<gl::State::DirtyBits::value_type>(gl::State::DIRTY_BIT_BLEND_EQUATIONS));
+#endif
     gl::State::DirtyBits mergedDirtyBits = gl::State::DirtyBits(dirtyBits) & ~resetBlendBitsMask;
     mergedDirtyBits.set(gl::State::DIRTY_BIT_BLEND_ENABLED, (dirtyBits & checkBlendBitsMask).any());
 
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index c037797..08fc75f 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -27,6 +27,10 @@
 #include "libANGLE/trace.h"
 #include "platform/Platform.h"
 
+#ifdef ANGLE_METAL_XCODE_BUILDS_SHADERS
+#    include "mtl_default_shaders_compiled.inc"
+#endif
+
 #include "EGL/eglext.h"
 
 #if defined(ANGLE_PLATFORM_MACOS) || defined(ANGLE_PLATFORM_MACCATALYST)
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index d3f9794..5847177 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -809,9 +809,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
     mtl::RenderPassAttachmentDesc &attachment = *attachmentOut;
 
-    if (!forceDepthStencilMultisampleLoad &&
-        (attachment.storeAction == MTLStoreActionDontCare ||
-         attachment.storeAction == MTLStoreActionMultisampleResolve))
+    if (!forceDepthStencilMultisampleLoad && attachment.storeAction == MTLStoreActionDontCare)
     {
         // If we previously discarded attachment's content, then don't need to load it.
         attachment.loadAction = MTLLoadActionDontCare;
@@ -1617,5 +1615,4 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
     return angle::Result::Continue;
 }
-
 }
diff --git a/src/libANGLE/renderer/metal/ProgramMtl.h b/src/libANGLE/renderer/metal/ProgramMtl.h
index 0e15681..96b77e2 100644
--- a/src/libANGLE/renderer/metal/ProgramMtl.h
+++ b/src/libANGLE/renderer/metal/ProgramMtl.h
@@ -18,6 +18,7 @@
 #include "common/Optional.h"
 #include "common/utilities.h"
 #include "libANGLE/renderer/ProgramImpl.h"
+#include "libANGLE/renderer/ShaderInterfaceVariableInfoMap.h"
 #include "libANGLE/renderer/glslang_wrapper_utils.h"
 #include "libANGLE/renderer/metal/mtl_buffer_pool.h"
 #include "libANGLE/renderer/metal/mtl_command_buffer.h"
diff --git a/src/libANGLE/renderer/metal/SurfaceMtl.mm b/src/libANGLE/renderer/metal/SurfaceMtl.mm
index 161ed51..95006fe 100644
--- a/src/libANGLE/renderer/metal/SurfaceMtl.mm
+++ b/src/libANGLE/renderer/metal/SurfaceMtl.mm
@@ -770,5 +770,4 @@
 {
     mSize.height = height;
 }
-
 }
diff --git a/src/libANGLE/renderer/metal/gen_mtl_format_table.py b/src/libANGLE/renderer/metal/gen_mtl_format_table.py
index f74a9cb..1cb8e81 100644
--- a/src/libANGLE/renderer/metal/gen_mtl_format_table.py
+++ b/src/libANGLE/renderer/metal/gen_mtl_format_table.py
@@ -364,7 +364,7 @@ def gen_image_map_switch_es3_case(angle_format, actual_angle_format_info, angle_
 
 
 # Generate format conversion switch case (ASTC LDR/HDR case)
-def gen_image_map_switch_astc_case(angle_format, angle_to_gl, angle_to_mtl_map):
+def gen_image_map_switch_astc_case_iosmac(angle_format, angle_to_gl, angle_to_mtl_map):
     gl_format = angle_to_gl[angle_format]
 
     def gen_format_assign_code(actual_angle_format, angle_to_mtl_map):
@@ -383,6 +383,20 @@ def gen_image_map_switch_astc_case(angle_format, angle_to_gl, angle_to_mtl_map):
                                      gen_format_assign_code)
 
 
+def gen_image_map_switch_astc_case_watchos(angle_format, angle_to_gl, angle_to_mtl_map):
+    gl_format = angle_to_gl[angle_format]
+
+    def gen_format_assign_code(actual_angle_format, angle_to_mtl_map):
+        return image_format_assign_template1.format(
+            actual_angle_format=actual_angle_format,
+            mtl_format=angle_to_mtl_map[actual_angle_format] + "LDR",
+            init_function=angle_format_utils.get_internal_format_initializer(
+                gl_format, actual_angle_format))
+
+    return gen_image_map_switch_case(angle_format, angle_format, angle_to_mtl_map,
+                                     gen_format_assign_code)
+
+
 def gen_image_map_switch_string(image_table, angle_to_gl):
     angle_override = image_table["override"]
     mac_override = image_table["override_mac"]
@@ -448,19 +462,36 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     for angle_format in sorted(sim_override.keys()):
         switch_data += gen_image_map_switch_simple_case(angle_format, sim_override[angle_format],
                                                         angle_to_gl, sim_angle_to_mtl)
+    switch_data += "#if TARGET_OS_IOS || TARGET_OS_TV\n"
     for angle_format in sorted(astc_tpl_map.keys()):
-        switch_data += gen_image_map_switch_astc_case(angle_format, angle_to_gl, astc_tpl_map)
+        switch_data += gen_image_map_switch_astc_case_iosmac(angle_format, angle_to_gl,
+                                                             astc_tpl_map)
+    switch_data += "#elif TARGET_OS_WATCH\n"
+
+    for angle_format in sorted(astc_tpl_map.keys()):
+        switch_data += gen_image_map_switch_astc_case_watchos(angle_format, angle_to_gl,
+                                                              astc_tpl_map)
+    switch_data += "#endif // TARGET_OS_IOS || TARGET_OS_TV \n "
     # iOS specific
-    switch_data += "#elif TARGET_OS_IOS || TARGET_OS_TV\n"
+    switch_data += "#elif TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST\n"
     for angle_format in sorted(ios_specific_map.keys()):
         switch_data += gen_image_map_switch_simple_case(angle_format, angle_format, angle_to_gl,
                                                         ios_specific_map)
     for angle_format in sorted(ios_override.keys()):
         switch_data += gen_image_map_switch_simple_case(angle_format, ios_override[angle_format],
                                                         angle_to_gl, ios_angle_to_mtl)
+    switch_data += "#if TARGET_OS_IOS || TARGET_OS_TV\n"
     for angle_format in sorted(astc_tpl_map.keys()):
-        switch_data += gen_image_map_switch_astc_case(angle_format, angle_to_gl, astc_tpl_map)
-    switch_data += "#endif\n"
+        switch_data += gen_image_map_switch_astc_case_iosmac(angle_format, angle_to_gl,
+                                                             astc_tpl_map)
+
+    switch_data += "#elif TARGET_OS_WATCH\n"
+
+    for angle_format in sorted(astc_tpl_map.keys()):
+        switch_data += gen_image_map_switch_astc_case_watchos(angle_format, angle_to_gl,
+                                                              astc_tpl_map)
+    switch_data += "#endif // TARGET_OS_IOS || TARGET_OS_TV\n"
+    switch_data += "#endif // TARGET_OS_IPHONE\n"
 
     # Try to support all iOS formats on newer macOS with Apple GPU.
     switch_data += "#if (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))\n"
@@ -475,8 +506,9 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
                                                             angle_to_gl, ios_specific_map)
     # ASTC LDR or HDR
     for angle_format in sorted(astc_tpl_map.keys()):
-        switch_data += gen_image_map_switch_astc_case(angle_format, angle_to_gl, astc_tpl_map)
-    switch_data += "#endif\n"
+        switch_data += gen_image_map_switch_astc_case_iosmac(angle_format, angle_to_gl,
+                                                             astc_tpl_map)
+    switch_data += "#endif // TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600)) \n"
 
     switch_data += "        default:\n"
     switch_data += "            this->metalFormat = MTLPixelFormatInvalid;\n"
@@ -505,7 +537,7 @@ def gen_image_mtl_to_angle_switch_string(image_table):
     switch_data += "#endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
 
     # iOS + macOS 11.0+ specific
-    switch_data += "#if TARGET_OS_IOS || TARGET_OS_TV || (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))\n"
+    switch_data += "#if TARGET_OS_IPHONE || (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))\n"
     for angle_format in sorted(ios_specific_map.keys()):
         # ETC1_R8G8B8_UNORM_BLOCK is a duplicated of ETC2_R8G8B8_UNORM_BLOCK
         if angle_format == 'ETC1_R8G8B8_UNORM_BLOCK':
@@ -515,9 +547,12 @@ def gen_image_mtl_to_angle_switch_string(image_table):
     for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += case_image_mtl_to_angle_template.format(
             mtl_format=astc_tpl_map[angle_format] + "LDR", angle_format=angle_format)
+    switch_data += "#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX \n"
+    for angle_format in sorted(astc_tpl_map.keys()):
         switch_data += case_image_mtl_to_angle_template.format(
             mtl_format=astc_tpl_map[angle_format] + "HDR", angle_format=angle_format)
-    switch_data += "#endif  // TARGET_OS_IOS || TARGET_OS_TV || mac 11.0+\n"
+    switch_data += "#endif // TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX\n"
+    switch_data += "#endif  // TARGET_OS_IPHONE || mac 11.0+\n"
 
     switch_data += "        default:\n"
     switch_data += "            return angle::FormatID::NONE;\n"
@@ -586,7 +621,8 @@ def gen_vertex_map_switch_string(vertex_table):
 def gen_mtl_format_caps_init_string(map_image):
     caps = map_image['caps']
     mac_caps = map_image['caps_mac']
-    ios_caps = map_image['caps_ios']
+    ios_platform_caps = map_image['caps_ios_platform']
+    ios_specific_caps = map_image['caps_ios_spcific']
     caps_init_str = ''
 
     def cap_to_param(caps, key):
@@ -616,12 +652,15 @@ def gen_mtl_format_caps_init_string(map_image):
     caps_init_str += caps_to_cpp(mac_caps)
     caps_init_str += "#endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST\n"
 
-    caps_init_str += "#if (TARGET_OS_IOS && !TARGET_OS_MACCATALYST) || TARGET_OS_TV || \\\n"
+    caps_init_str += "#if (TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST) || \\\n"
     caps_init_str += "    (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))\n"
 
-    caps_init_str += caps_to_cpp(ios_caps)
+    caps_init_str += caps_to_cpp(ios_platform_caps)
 
-    caps_init_str += "#endif\n"
+    caps_init_str += "#if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX\n"
+    caps_init_str += caps_to_cpp(ios_specific_caps)
+    caps_init_str += "#endif // TARGET_OS_IOS || TARGET_OS_TV || mac 11.0+ \n"
+    caps_init_str += "#endif // TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST || mac 11.0+ \n"
 
     return caps_init_str
 
diff --git a/src/libANGLE/renderer/metal/mtl_buffer_pool.h b/src/libANGLE/renderer/metal/mtl_buffer_pool.h
index c3be11f..204ebb9 100644
--- a/src/libANGLE/renderer/metal/mtl_buffer_pool.h
+++ b/src/libANGLE/renderer/metal/mtl_buffer_pool.h
@@ -126,7 +126,7 @@ class BufferPool
 
     size_t mBuffersAllocated;
     size_t mMaxBuffers;
-    BufferPoolMemPolicy mMemPolicy;
+    BufferPoolMemPolicy mMemPolicy = BufferPoolMemPolicy::Auto;
     bool mAlwaysAllocateNewBuffer;
 };
 
diff --git a/src/libANGLE/renderer/metal/mtl_format_map.json b/src/libANGLE/renderer/metal/mtl_format_map.json
index 2a63665..6d80191 100644
--- a/src/libANGLE/renderer/metal/mtl_format_map.json
+++ b/src/libANGLE/renderer/metal/mtl_format_map.json
@@ -74,7 +74,6 @@
             "D32_FLOAT": "MTLPixelFormatDepth32Float",
             "S8_UINT": "MTLPixelFormatStencil8",
             "D32_FLOAT_S8X24_UINT": "MTLPixelFormatDepth32Float_Stencil8",
-            "B10G10R10A2_UNORM": "MTLPixelFormatBGR10A2Unorm",
             "R10G10B10A2_UINT": "MTLPixelFormatRGB10A2Uint",
             "R10G10B10A2_UNORM": "MTLPixelFormatRGB10A2Unorm",
             "R11G11B10_FLOAT": "MTLPixelFormatRG11B10Float",
@@ -105,20 +104,20 @@
             "EAC_R11_SNORM_BLOCK": "MTLPixelFormatEAC_R11Snorm",
             "EAC_R11G11_UNORM_BLOCK": "MTLPixelFormatEAC_RG11Unorm",
             "EAC_R11G11_SNORM_BLOCK": "MTLPixelFormatEAC_RG11Snorm",
-            "ASTC_4x4_SRGB_BLOCK": "MTLPixelFormatASTC_4x4_sRGB",
-            "ASTC_5x4_SRGB_BLOCK": "MTLPixelFormatASTC_5x4_sRGB",
-            "ASTC_5x5_SRGB_BLOCK": "MTLPixelFormatASTC_5x5_sRGB",
-            "ASTC_6x5_SRGB_BLOCK": "MTLPixelFormatASTC_6x5_sRGB",
-            "ASTC_6x6_SRGB_BLOCK": "MTLPixelFormatASTC_6x6_sRGB",
-            "ASTC_8x5_SRGB_BLOCK": "MTLPixelFormatASTC_8x5_sRGB",
-            "ASTC_8x6_SRGB_BLOCK": "MTLPixelFormatASTC_8x6_sRGB",
-            "ASTC_8x8_SRGB_BLOCK": "MTLPixelFormatASTC_8x8_sRGB",
-            "ASTC_10x5_SRGB_BLOCK": "MTLPixelFormatASTC_10x5_sRGB",
-            "ASTC_10x6_SRGB_BLOCK": "MTLPixelFormatASTC_10x6_sRGB",
-            "ASTC_10x8_SRGB_BLOCK": "MTLPixelFormatASTC_10x8_sRGB",
-            "ASTC_10x10_SRGB_BLOCK": "MTLPixelFormatASTC_10x10_sRGB",
-            "ASTC_12x10_SRGB_BLOCK": "MTLPixelFormatASTC_12x10_sRGB",
-            "ASTC_12x12_SRGB_BLOCK": "MTLPixelFormatASTC_12x12_sRGB"
+            "ASTC_4x4_SRGB_BLOCK" : "MTLPixelFormatASTC_4x4_sRGB",
+            "ASTC_5x4_SRGB_BLOCK" : "MTLPixelFormatASTC_5x4_sRGB",
+            "ASTC_5x5_SRGB_BLOCK" : "MTLPixelFormatASTC_5x5_sRGB",
+            "ASTC_6x5_SRGB_BLOCK" : "MTLPixelFormatASTC_6x5_sRGB",
+            "ASTC_6x6_SRGB_BLOCK" : "MTLPixelFormatASTC_6x6_sRGB",
+            "ASTC_8x5_SRGB_BLOCK" : "MTLPixelFormatASTC_8x5_sRGB",
+            "ASTC_8x6_SRGB_BLOCK" : "MTLPixelFormatASTC_8x6_sRGB",
+            "ASTC_8x8_SRGB_BLOCK" : "MTLPixelFormatASTC_8x8_sRGB",
+            "ASTC_10x5_SRGB_BLOCK" : "MTLPixelFormatASTC_10x5_sRGB",
+            "ASTC_10x6_SRGB_BLOCK" : "MTLPixelFormatASTC_10x6_sRGB",
+            "ASTC_10x8_SRGB_BLOCK" : "MTLPixelFormatASTC_10x8_sRGB",
+            "ASTC_10x10_SRGB_BLOCK" : "MTLPixelFormatASTC_10x10_sRGB",
+            "ASTC_12x10_SRGB_BLOCK" : "MTLPixelFormatASTC_12x10_sRGB",
+            "ASTC_12x12_SRGB_BLOCK" : "MTLPixelFormatASTC_12x12_sRGB"
         },
         "map_sim": {
             "ETC1_R8G8B8_UNORM_BLOCK": "MTLPixelFormatETC2_RGB8",
@@ -130,7 +129,7 @@
             "ETC2_R8G8B8A8_SRGB_BLOCK": "MTLPixelFormatEAC_RGBA8_sRGB",
             "EAC_R11_UNORM_BLOCK": "MTLPixelFormatEAC_R11Unorm",
             "EAC_R11_SNORM_BLOCK": "MTLPixelFormatEAC_R11Snorm",
-            "EAC_R11G11_UNORM_BLOCK": "MTLPixelFormatEAC_R11Unorm",
+            "EAC_R11G11_UNORM_BLOCK": "MTLPixelFormatEAC_RG11Unorm",
             "EAC_R11G11_SNORM_BLOCK": "MTLPixelFormatEAC_RG11Snorm",
             "ASTC_4x4_SRGB_BLOCK": "MTLPixelFormatASTC_4x4_sRGB",
             "ASTC_5x4_SRGB_BLOCK": "MTLPixelFormatASTC_5x4_sRGB",
@@ -145,21 +144,7 @@
             "ASTC_10x8_SRGB_BLOCK": "MTLPixelFormatASTC_10x8_sRGB",
             "ASTC_10x10_SRGB_BLOCK": "MTLPixelFormatASTC_10x10_sRGB",
             "ASTC_12x10_SRGB_BLOCK": "MTLPixelFormatASTC_12x10_sRGB",
-            "ASTC_12x12_SRGB_BLOCK": "MTLPixelFormatASTC_12x12_sRGB",
-            "ASTC_4x4_UNORM_BLOCK": "MTLPixelFormatASTC_4x4_LDR",
-            "ASTC_5x4_UNORM_BLOCK": "MTLPixelFormatASTC_5x4_LDR",
-            "ASTC_5x5_UNORM_BLOCK": "MTLPixelFormatASTC_5x5_LDR",
-            "ASTC_6x5_UNORM_BLOCK": "MTLPixelFormatASTC_6x5_LDR",
-            "ASTC_6x6_UNORM_BLOCK": "MTLPixelFormatASTC_6x6_LDR",
-            "ASTC_8x5_UNORM_BLOCK": "MTLPixelFormatASTC_8x5_LDR",
-            "ASTC_8x6_UNORM_BLOCK": "MTLPixelFormatASTC_8x6_LDR",
-            "ASTC_8x8_UNORM_BLOCK": "MTLPixelFormatASTC_8x8_LDR",
-            "ASTC_10x5_UNORM_BLOCK": "MTLPixelFormatASTC_10x5_LDR",
-            "ASTC_10x6_UNORM_BLOCK": "MTLPixelFormatASTC_10x6_LDR",
-            "ASTC_10x8_UNORM_BLOCK": "MTLPixelFormatASTC_10x8_LDR",
-            "ASTC_10x10_UNORM_BLOCK": "MTLPixelFormatASTC_10x10_LDR",
-            "ASTC_12x10_UNORM_BLOCK": "MTLPixelFormatASTC_12x10_LDR",
-            "ASTC_12x12_UNORM_BLOCK": "MTLPixelFormatASTC_12x12_LDR"
+            "ASTC_12x12_SRGB_BLOCK": "MTLPixelFormatASTC_12x12_sRGB"
         },
         "map_astc_tpl": {
             "ASTC_4x4_UNORM_BLOCK": "MTLPixelFormatASTC_4x4_",
@@ -230,7 +215,8 @@
             "R5G6B5_UNORM": "R8G8B8A8_UNORM",
             "R5G5B5A1_UNORM": "R8G8B8A8_UNORM",
             "D24_UNORM_S8_UINT": "D32_FLOAT_S8X24_UINT",
-            "R4G4B4A4_UNORM": "R8G8B8A8_UNORM"
+            "R4G4B4A4_UNORM": "R8G8B8A8_UNORM",
+            "D16_UNORM": "D32_FLOAT"
         },
         "override_mac_bc1": {
             "BC1_RGB_UNORM_BLOCK": {
@@ -261,6 +247,8 @@
         "d24s8_fallbacks_mac": {
             "D24_UNORM_S8_UINT": "D32_FLOAT_S8X24_UINT"
         },
+        "fallbacks_ios": {
+        },
         "caps": {
             "MTLPixelFormatA8Unorm":{
                 "filterable": "true",
@@ -623,7 +611,7 @@
                 "colorRenderable": "true"
             },
             "MTLPixelFormatDepth32Float":{
-                "filterable": "display->supportsEitherGPUFamily(1, 1)",
+                "filterable": "display->supports32BitFloatFiltering()",
                 "writable": "false",
                 "blendable": "false",
                 "multisample": "true",
@@ -641,7 +629,7 @@
                 "depthRenderable": "true"
             },
             "MTLPixelFormatDepth32Float_Stencil8":{
-                "filterable": "display->supportsEitherGPUFamily(1, 1)",
+                "filterable": "display->supports32BitFloatFiltering()",
                 "writable": "false",
                 "blendable": "false",
                 "multisample": "true",
@@ -661,13 +649,13 @@
                 "depthRenderable": "true"
             },
             "MTLPixelFormatDepth24Unorm_Stencil8":{
-                "filterable": "display->supportsMacGPUFamily(1)",
+                "filterable": "display->supportsMacGPUFamily(1) && display->supportsDepth24Stencil8PixelFormat()",
                 "writable": "false",
                 "blendable": "false",
                 "multisample": "true",
                 "resolve": "supportDepthStencilAutoResolve",
                 "colorRenderable": "false",
-                "depthRenderable": "display->supportsMacGPUFamily(1)"
+                "depthRenderable": "display->supportsMacGPUFamily(1) && display->supportsDepth24Stencil8PixelFormat()"
             },
             "MTLPixelFormatBC1_RGBA":{
                 "filterable": "true"
@@ -712,7 +700,7 @@
                 "filterable": "true"
             }
         },
-        "caps_ios": {
+        "caps_ios_platform": {
             "MTLPixelFormatR8Unorm_sRGB":{
                 "filterable": "display->supportsAppleGPUFamily(1)",
                 "writable": "display->supportsAppleGPUFamily(2)",
@@ -898,7 +886,10 @@
             },
             "MTLPixelFormatASTC_12x12_sRGB":{
                 "filterable": "display->supportsAppleGPUFamily(2)"
+            }
         },
+        "caps_ios_spcific" :
+        {
             "MTLPixelFormatASTC_4x4_HDR":{
                 "filterable": "display->supportsAppleGPUFamily(6)"
             },
diff --git a/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm b/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
index e57ba28..7c8dd7a 100644
--- a/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
+++ b/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
@@ -33,8 +33,6 @@
     {
         case MTLPixelFormatA8Unorm:
             return angle::FormatID::A8_UNORM;
-        case MTLPixelFormatBGR10A2Unorm:
-            return angle::FormatID::B10G10R10A2_UNORM;
         case MTLPixelFormatBGRA8Unorm:
             return angle::FormatID::B8G8R8A8_UNORM;
         case MTLPixelFormatBGRA8Unorm_sRGB:
@@ -161,7 +159,7 @@
         case MTLPixelFormatDepth24Unorm_Stencil8:
             return angle::FormatID::D24_UNORM_S8_UINT;
 #endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST
-#if TARGET_OS_IOS || TARGET_OS_TV || (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
+#if TARGET_OS_IPHONE || (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
         case MTLPixelFormatASTC_10x10_sRGB:
             return angle::FormatID::ASTC_10x10_SRGB_BLOCK;
         case MTLPixelFormatASTC_10x5_sRGB:
@@ -238,61 +236,63 @@
             return angle::FormatID::R8_UNORM_SRGB;
         case MTLPixelFormatASTC_10x10_LDR:
             return angle::FormatID::ASTC_10x10_UNORM_BLOCK;
-        case MTLPixelFormatASTC_10x10_HDR:
-            return angle::FormatID::ASTC_10x10_UNORM_BLOCK;
         case MTLPixelFormatASTC_10x5_LDR:
             return angle::FormatID::ASTC_10x5_UNORM_BLOCK;
-        case MTLPixelFormatASTC_10x5_HDR:
-            return angle::FormatID::ASTC_10x5_UNORM_BLOCK;
         case MTLPixelFormatASTC_10x6_LDR:
             return angle::FormatID::ASTC_10x6_UNORM_BLOCK;
-        case MTLPixelFormatASTC_10x6_HDR:
-            return angle::FormatID::ASTC_10x6_UNORM_BLOCK;
         case MTLPixelFormatASTC_10x8_LDR:
             return angle::FormatID::ASTC_10x8_UNORM_BLOCK;
-        case MTLPixelFormatASTC_10x8_HDR:
-            return angle::FormatID::ASTC_10x8_UNORM_BLOCK;
         case MTLPixelFormatASTC_12x10_LDR:
             return angle::FormatID::ASTC_12x10_UNORM_BLOCK;
-        case MTLPixelFormatASTC_12x10_HDR:
-            return angle::FormatID::ASTC_12x10_UNORM_BLOCK;
         case MTLPixelFormatASTC_12x12_LDR:
             return angle::FormatID::ASTC_12x12_UNORM_BLOCK;
-        case MTLPixelFormatASTC_12x12_HDR:
-            return angle::FormatID::ASTC_12x12_UNORM_BLOCK;
         case MTLPixelFormatASTC_4x4_LDR:
             return angle::FormatID::ASTC_4x4_UNORM_BLOCK;
-        case MTLPixelFormatASTC_4x4_HDR:
-            return angle::FormatID::ASTC_4x4_UNORM_BLOCK;
         case MTLPixelFormatASTC_5x4_LDR:
             return angle::FormatID::ASTC_5x4_UNORM_BLOCK;
-        case MTLPixelFormatASTC_5x4_HDR:
-            return angle::FormatID::ASTC_5x4_UNORM_BLOCK;
         case MTLPixelFormatASTC_5x5_LDR:
             return angle::FormatID::ASTC_5x5_UNORM_BLOCK;
-        case MTLPixelFormatASTC_5x5_HDR:
-            return angle::FormatID::ASTC_5x5_UNORM_BLOCK;
         case MTLPixelFormatASTC_6x5_LDR:
             return angle::FormatID::ASTC_6x5_UNORM_BLOCK;
-        case MTLPixelFormatASTC_6x5_HDR:
-            return angle::FormatID::ASTC_6x5_UNORM_BLOCK;
         case MTLPixelFormatASTC_6x6_LDR:
             return angle::FormatID::ASTC_6x6_UNORM_BLOCK;
-        case MTLPixelFormatASTC_6x6_HDR:
-            return angle::FormatID::ASTC_6x6_UNORM_BLOCK;
         case MTLPixelFormatASTC_8x5_LDR:
             return angle::FormatID::ASTC_8x5_UNORM_BLOCK;
-        case MTLPixelFormatASTC_8x5_HDR:
-            return angle::FormatID::ASTC_8x5_UNORM_BLOCK;
         case MTLPixelFormatASTC_8x6_LDR:
             return angle::FormatID::ASTC_8x6_UNORM_BLOCK;
-        case MTLPixelFormatASTC_8x6_HDR:
-            return angle::FormatID::ASTC_8x6_UNORM_BLOCK;
         case MTLPixelFormatASTC_8x8_LDR:
             return angle::FormatID::ASTC_8x8_UNORM_BLOCK;
+#    if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX
+        case MTLPixelFormatASTC_10x10_HDR:
+            return angle::FormatID::ASTC_10x10_UNORM_BLOCK;
+        case MTLPixelFormatASTC_10x5_HDR:
+            return angle::FormatID::ASTC_10x5_UNORM_BLOCK;
+        case MTLPixelFormatASTC_10x6_HDR:
+            return angle::FormatID::ASTC_10x6_UNORM_BLOCK;
+        case MTLPixelFormatASTC_10x8_HDR:
+            return angle::FormatID::ASTC_10x8_UNORM_BLOCK;
+        case MTLPixelFormatASTC_12x10_HDR:
+            return angle::FormatID::ASTC_12x10_UNORM_BLOCK;
+        case MTLPixelFormatASTC_12x12_HDR:
+            return angle::FormatID::ASTC_12x12_UNORM_BLOCK;
+        case MTLPixelFormatASTC_4x4_HDR:
+            return angle::FormatID::ASTC_4x4_UNORM_BLOCK;
+        case MTLPixelFormatASTC_5x4_HDR:
+            return angle::FormatID::ASTC_5x4_UNORM_BLOCK;
+        case MTLPixelFormatASTC_5x5_HDR:
+            return angle::FormatID::ASTC_5x5_UNORM_BLOCK;
+        case MTLPixelFormatASTC_6x5_HDR:
+            return angle::FormatID::ASTC_6x5_UNORM_BLOCK;
+        case MTLPixelFormatASTC_6x6_HDR:
+            return angle::FormatID::ASTC_6x6_UNORM_BLOCK;
+        case MTLPixelFormatASTC_8x5_HDR:
+            return angle::FormatID::ASTC_8x5_UNORM_BLOCK;
+        case MTLPixelFormatASTC_8x6_HDR:
+            return angle::FormatID::ASTC_8x6_UNORM_BLOCK;
         case MTLPixelFormatASTC_8x8_HDR:
             return angle::FormatID::ASTC_8x8_UNORM_BLOCK;
-#endif  // TARGET_OS_IOS || TARGET_OS_TV || mac 11.0+
+#    endif  // TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX
+#endif      // TARGET_OS_IPHONE || mac 11.0+
         default:
             return angle::FormatID::NONE;
     }
@@ -317,15 +317,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::B10G10R10A2_UNORM:
-
-            this->metalFormat    = MTLPixelFormatBGR10A2Unorm;
-            this->actualFormatId = angle::FormatID::B10G10R10A2_UNORM;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::B8G8R8A8_UNORM:
 
             this->metalFormat    = MTLPixelFormatBGRA8Unorm;
@@ -1304,15 +1295,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_10x10_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_10x10_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_10x5_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_10x5_sRGB;
@@ -1322,15 +1304,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_10x5_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_10x5_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_10x5_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_10x6_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_10x6_sRGB;
@@ -1340,15 +1313,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_10x6_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_10x6_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_10x6_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_10x8_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_10x8_sRGB;
@@ -1358,15 +1322,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_10x8_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_10x8_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_10x8_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_12x10_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_12x10_sRGB;
@@ -1376,15 +1331,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_12x10_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_12x10_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_12x10_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_12x12_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_12x12_sRGB;
@@ -1394,15 +1340,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_12x12_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_12x12_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_12x12_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_4x4_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_4x4_sRGB;
@@ -1412,15 +1349,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_4x4_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_4x4_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_4x4_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_5x4_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_5x4_sRGB;
@@ -1430,15 +1358,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_5x4_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_5x4_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_5x4_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_5x5_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_5x5_sRGB;
@@ -1448,15 +1367,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_5x5_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_5x5_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_5x5_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_6x5_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_6x5_sRGB;
@@ -1466,15 +1376,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_6x5_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_6x5_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_6x5_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_6x6_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_6x6_sRGB;
@@ -1484,15 +1385,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_6x6_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_6x6_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_6x6_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_8x5_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_8x5_sRGB;
@@ -1502,15 +1394,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_8x5_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_8x5_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_8x5_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_8x6_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_8x6_sRGB;
@@ -1520,15 +1403,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_8x6_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_8x6_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_8x6_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::ASTC_8x8_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_8x8_sRGB;
@@ -1538,15 +1412,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::ASTC_8x8_UNORM_BLOCK:
-
-            this->metalFormat    = MTLPixelFormatASTC_8x8_LDR;
-            this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::EAC_R11G11_SNORM_BLOCK:
 
             this->metalFormat    = MTLPixelFormatEAC_RG11Snorm;
@@ -1558,7 +1423,7 @@
 
         case angle::FormatID::EAC_R11G11_UNORM_BLOCK:
 
-            this->metalFormat    = MTLPixelFormatEAC_R11Unorm;
+            this->metalFormat    = MTLPixelFormatEAC_RG11Unorm;
             this->actualFormatId = angle::FormatID::EAC_R11G11_UNORM_BLOCK;
             this->initFunction   = nullptr;
 
@@ -1646,6 +1511,15 @@
             this->swizzled = false;
             break;
 
+        case angle::FormatID::D16_UNORM:
+
+            this->metalFormat    = MTLPixelFormatDepth32Float;
+            this->actualFormatId = angle::FormatID::D32_FLOAT;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
         case angle::FormatID::D24_UNORM_S8_UINT:
 
             this->metalFormat    = MTLPixelFormatDepth32Float_Stencil8;
@@ -1682,6 +1556,7 @@
             this->swizzled = false;
             break;
 
+#    if TARGET_OS_IOS || TARGET_OS_TV
         case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
 
             if (display->supportsAppleGPUFamily(6))
@@ -1911,30 +1786,158 @@
                 this->metalFormat    = MTLPixelFormatASTC_8x6_LDR;
                 this->actualFormatId = angle::FormatID::ASTC_8x6_UNORM_BLOCK;
                 this->initFunction   = nullptr;
-            }
+            }
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x8_UNORM_BLOCK:
+
+            if (display->supportsAppleGPUFamily(6))
+            {
+                this->metalFormat    = MTLPixelFormatASTC_8x8_HDR;
+                this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
+                this->initFunction   = nullptr;
+            }
+            else
+            {
+                this->metalFormat    = MTLPixelFormatASTC_8x8_LDR;
+                this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
+                this->initFunction   = nullptr;
+            }
+
+            this->swizzled = false;
+            break;
+
+#    elif TARGET_OS_WATCH
+        case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x10_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x10_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x6_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x6_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x8_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x8_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x8_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x10_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_12x10_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_12x10_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x12_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_12x12_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_12x12_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_4x4_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_4x4_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_4x4_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x4_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_5x4_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_5x4_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_5x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_5x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_6x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_6x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x6_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_6x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_6x6_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_8x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x6_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_8x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x6_UNORM_BLOCK;
+            this->initFunction   = nullptr;
 
             this->swizzled = false;
             break;
 
         case angle::FormatID::ASTC_8x8_UNORM_BLOCK:
 
-            if (display->supportsAppleGPUFamily(6))
-            {
-                this->metalFormat    = MTLPixelFormatASTC_8x8_HDR;
-                this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
-                this->initFunction   = nullptr;
-            }
-            else
-            {
             this->metalFormat    = MTLPixelFormatASTC_8x8_LDR;
             this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
             this->initFunction   = nullptr;
-            }
 
             this->swizzled = false;
             break;
 
-#elif TARGET_OS_IOS || TARGET_OS_TV
+#    endif  // TARGET_OS_IOS || TARGET_OS_TV
+#elif TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST
         case angle::FormatID::ASTC_10x10_SRGB_BLOCK:
 
             this->metalFormat    = MTLPixelFormatASTC_10x10_sRGB;
@@ -2295,6 +2298,7 @@
             this->swizzled = false;
             break;
 
+#    if TARGET_OS_IOS || TARGET_OS_TV
         case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
 
             if (display->supportsAppleGPUFamily(6))
@@ -2547,7 +2551,135 @@
             this->swizzled = false;
             break;
 
-#endif
+#    elif TARGET_OS_WATCH
+        case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x10_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x10_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x6_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x6_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x8_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_10x8_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x8_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x10_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_12x10_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_12x10_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x12_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_12x12_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_12x12_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_4x4_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_4x4_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_4x4_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x4_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_5x4_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_5x4_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_5x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_5x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_6x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_6x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x6_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_6x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_6x6_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x5_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_8x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x5_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x6_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_8x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x6_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x8_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatASTC_8x8_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
+            this->initFunction   = nullptr;
+
+            this->swizzled = false;
+            break;
+
+#    endif  // TARGET_OS_IOS || TARGET_OS_TV
+#endif      // TARGET_OS_IPHONE
 #if (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
         case angle::FormatID::ASTC_10x10_SRGB_BLOCK:
 
@@ -3269,7 +3401,7 @@
             this->swizzled = false;
             break;
 
-#endif
+#endif  // TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
         default:
             this->metalFormat    = MTLPixelFormatInvalid;
             this->actualFormatId = angle::FormatID::NONE;
@@ -4411,13 +4543,13 @@
                   /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatDepth32Float,
-                  /** filterable*/ display->supportsEitherGPUFamily(1, 1), /** writable*/ false,
+                  /** filterable*/ display->supports32BitFloatFiltering(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ true,
                   /** resolve*/ supportDepthAutoResolve, /** colorRenderable*/ false,
                   /** depthRenderable*/ true);
 
     setFormatCaps(MTLPixelFormatDepth32Float_Stencil8,
-                  /** filterable*/ display->supportsEitherGPUFamily(1, 1), /** writable*/ false,
+                  /** filterable*/ display->supports32BitFloatFiltering(), /** writable*/ false,
                   /** blendable*/ false, /** multisample*/ true,
                   /** resolve*/ supportDepthStencilAutoResolve, /** colorRenderable*/ false,
                   /** depthRenderable*/ true);
@@ -4676,13 +4808,15 @@
                   /** depthRenderable*/ true);
 
     setFormatCaps(MTLPixelFormatDepth24Unorm_Stencil8,
-                  /** filterable*/ display->supportsMacGPUFamily(1), /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ true,
+                  /** filterable*/ display->supportsMacGPUFamily(1) &&
+                      display->supportsDepth24Stencil8PixelFormat(),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ true,
                   /** resolve*/ supportDepthStencilAutoResolve, /** colorRenderable*/ false,
-                  /** depthRenderable*/ display->supportsMacGPUFamily(1));
+                  /** depthRenderable*/ display->supportsMacGPUFamily(1) &&
+                      display->supportsDepth24Stencil8PixelFormat());
 
 #endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST
-#if (TARGET_OS_IOS && !TARGET_OS_MACCATALYST) || TARGET_OS_TV || \
+#if (TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST) || \
     (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
     setFormatCaps(MTLPixelFormatA1BGR5Unorm, /** filterable*/ display->supportsAppleGPUFamily(1),
                   /** writable*/ false, /** blendable*/ display->supportsAppleGPUFamily(1),
@@ -4698,10 +4832,6 @@
                   /** colorRenderable*/ display->supportsAppleGPUFamily(1),
                   /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_10x10_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_10x10_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4711,10 +4841,6 @@
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_10x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_10x5_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4723,10 +4849,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_10x6_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_10x6_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4735,10 +4857,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_10x8_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_10x8_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4747,10 +4865,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_12x10_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_12x10_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4760,10 +4874,6 @@
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_12x12_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_12x12_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4773,10 +4883,6 @@
                   /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
                   /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_4x4_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_4x4_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4785,10 +4891,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_5x4_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_5x4_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4797,10 +4899,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_5x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_5x5_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4809,10 +4907,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_6x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_6x5_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4821,10 +4915,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_6x6_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_6x6_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4833,10 +4923,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_8x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_8x5_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4845,10 +4931,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_8x6_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_8x6_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4857,10 +4939,6 @@
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatASTC_8x8_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
-                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
-                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
-
     setFormatCaps(MTLPixelFormatASTC_8x8_LDR, /** filterable*/ display->supportsAppleGPUFamily(2),
                   /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
                   /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
@@ -4978,7 +5056,65 @@
                   /** colorRenderable*/ display->supportsAppleGPUFamily(1),
                   /** depthRenderable*/ false);
 
-#endif
+#    if TARGET_OS_IOS || TARGET_OS_TV || TARGET_OS_OSX
+    setFormatCaps(MTLPixelFormatASTC_10x10_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_10x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_10x6_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_10x8_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_12x10_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_12x12_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_4x4_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_5x4_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_5x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_6x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_6x6_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_8x5_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_8x6_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+    setFormatCaps(MTLPixelFormatASTC_8x8_HDR, /** filterable*/ display->supportsAppleGPUFamily(6),
+                  /** writable*/ false, /** blendable*/ false, /** multisample*/ false,
+                  /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
+
+#    endif  // TARGET_OS_IOS || TARGET_OS_TV || mac 11.0+
+#endif      // TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST || mac 11.0+
 }
 
 }  // namespace mtl
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index 17faa40..2d8d910 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -2553,45 +2553,13 @@ ANGLE_INLINE void SetPipelineState(ComputeCommandEncoder *encoder,
                                             bool sRGBMipmap,
                                             NativeTexLevelArray *mipmapOutputViews)
 {
-    // Only support 3D texture for now.
-    ASSERT(srcTexture->textureType() == MTLTextureType3D);
-
     MTLSize threadGroupSize;
     uint32_t slices                             = 1;
     id<MTLComputePipelineState> computePipeline = nil;
-
-    ensure3DMipGeneratorPipelineInitialized(contextMtl);
-    computePipeline = m3DMipGeneratorPipeline;
-    threadGroupSize =
-        MTLSizeMake(kGenerateMipThreadGroupSizePerDim, kGenerateMipThreadGroupSizePerDim,
-                    kGenerateMipThreadGroupSizePerDim);
-
     // The compute shader supports up to 4 mipmaps generated per pass.
     // See shaders/gen_mipmap.metal
     uint32_t maxMipsPerBatch = 4;
 
-    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
-            computePipeline.maxTotalThreadsPerThreadgroup ||
-        ANGLE_UNLIKELY(
-            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
-    {
-        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
-        // Fallback to generate one mip per pass and reduce thread group size.
-        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
-                           computePipeline.maxTotalThreadsPerThreadgroup))
-        {
-            // Even with reduced thread group size, we cannot proceed.
-            // HACK: use blit command encoder to generate mipmaps if it is not possible
-            // to use compute shader due to hardware limits.
-            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
-            blitEncoder->generateMipmapsForTexture(srcTexture);
-            return angle::Result::Continue;
-        }
-
-        threadGroupSize.depth = 1;
-        maxMipsPerBatch       = 1;
-    }
-
     ComputeCommandEncoder *cmdEncoder = contextMtl->getComputeCommandEncoder();
     ASSERT(cmdEncoder);
 
@@ -2628,8 +2596,29 @@ ANGLE_INLINE void SetPipelineState(ComputeCommandEncoder *encoder,
             UNREACHABLE();
     }
 
-    Generate3DMipmapUniform options;
+    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
+            computePipeline.maxTotalThreadsPerThreadgroup ||
+        ANGLE_UNLIKELY(
+            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
+    {
+        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
+        // Fallback to generate one mip per pass and reduce thread group size.
+        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
+                           computePipeline.maxTotalThreadsPerThreadgroup))
+        {
+            // Even with reduced thread group size, we cannot proceed.
+            // HACK: use blit command encoder to generate mipmaps if it is not possible
+            // to use compute shader due to hardware limits.
+            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
+            blitEncoder->generateMipmapsForTexture(srcTexture);
+            return angle::Result::Continue;
+        }
+
+        threadGroupSize.depth = 1;
+        maxMipsPerBatch       = 1;
+    }
 
+    Generate3DMipmapUniform options;
     uint32_t remainMips             = srcTexture->mipmapLevels() - 1;
     MipmapNativeLevel batchSrcLevel = kZeroNativeMipLevel;
     options.srcLevel                = batchSrcLevel.get();
diff --git a/src/libANGLE/renderer/metal/mtl_resources.h b/src/libANGLE/renderer/metal/mtl_resources.h
index b51294c..b51378a 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.h
+++ b/src/libANGLE/renderer/metal/mtl_resources.h
@@ -337,7 +337,9 @@ class Texture final : public Resource,
     TextureRef mReadCopy;
 };
 
-class Buffer final : public Resource, public WrappedObject<id<MTLBuffer>>
+class Buffer final : public Resource,
+                     public WrappedObject<id<MTLBuffer>>,
+                     public std::enable_shared_from_this<Buffer>
 {
   public:
     static angle::Result MakeBuffer(ContextMtl *context,
diff --git a/src/libANGLE/renderer/metal/mtl_resources.mm b/src/libANGLE/renderer/metal/mtl_resources.mm
index 2c1d582..9a5542d 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.mm
+++ b/src/libANGLE/renderer/metal/mtl_resources.mm
@@ -35,12 +35,14 @@ inline NSUInteger GetMipSize(NSUInteger baseSize, const MipmapNativeLevel level)
 // Asynchronously synchronize the content of a resource between GPU memory and its CPU cache.
 // NOTE: This operation doesn't finish immediately upon function's return.
 template <class T>
-void InvokeCPUMemSync(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder, T *resource)
+void InvokeCPUMemSync(ContextMtl *context,
+                      mtl::BlitCommandEncoder *blitEncoder,
+                      const std::shared_ptr<T> &resource)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     if (blitEncoder)
     {
-        blitEncoder->synchronizeResource(resource);
+        blitEncoder->synchronizeResource(resource.get());
 
         resource->resetCPUReadMemNeedSync();
         resource->setCPUReadMemSyncPending(true);
@@ -49,7 +51,7 @@ void InvokeCPUMemSync(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder,
 }
 
 template <class T>
-void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
+void EnsureCPUMemWillBeSynced(ContextMtl *context, const std::shared_ptr<T> &resource)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     // Make sure GPU & CPU contents are synchronized.
@@ -496,12 +498,12 @@ void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
 
 void Texture::syncContent(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder)
 {
-    InvokeCPUMemSync(context, blitEncoder, this);
+    InvokeCPUMemSync(context, blitEncoder, shared_from_this());
 }
 
 void Texture::syncContentIfNeeded(ContextMtl *context)
 {
-    EnsureCPUMemWillBeSynced(context, this);
+    EnsureCPUMemWillBeSynced(context, shared_from_this());
 }
 
 bool Texture::isCPUAccessible() const
@@ -982,7 +984,7 @@ void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
 
 void Buffer::syncContent(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder)
 {
-    InvokeCPUMemSync(context, blitEncoder, this);
+    InvokeCPUMemSync(context, blitEncoder, shared_from_this());
 }
 
 const uint8_t *Buffer::mapReadOnly(ContextMtl *context)
@@ -1003,7 +1005,7 @@ void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
     {
         CommandQueue &cmdQueue = context->cmdQueue();
 
-        EnsureCPUMemWillBeSynced(context, this);
+        EnsureCPUMemWillBeSynced(context, shared_from_this());
 
         if (this->isBeingUsedByGPU(context))
         {
diff --git a/src/libANGLE/renderer/metal/mtl_utils.h b/src/libANGLE/renderer/metal/mtl_utils.h
index 817016b..8ae47a1 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.h
+++ b/src/libANGLE/renderer/metal/mtl_utils.h
@@ -107,11 +107,9 @@ AutoObjCPtr<id<MTLLibrary>> CreateShaderLibrary(
     bool enableFastMath,
     AutoObjCPtr<NSError *> *error);
 
-AutoObjCPtr<id<MTLLibrary>> CreateShaderLibraryFromBinary(
-    id<MTLDevice> metalDevice,
+AutoObjCPtr<id<MTLLibrary>> CreateShaderLibraryFromBinary(id<MTLDevice> metalDevice,
                                                           const uint8_t *binarySource,
                                                           size_t binarySourceLen,
-    NSDictionary<NSString *, NSObject *> *substitutionDictionary,
                                                           AutoObjCPtr<NSError *> *error);
 
 bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily);
diff --git a/src/libANGLE/renderer/metal/mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_utils.mm
index 0c3cd66..ea92fc9 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_utils.mm
@@ -374,7 +374,13 @@ bool GetCompressedBufferSizeAndRowLengthForTextureWithFormat(const TextureRef &t
     // Intiialize the content to black
     GLint layer, startDepth;
     GetSliceAndDepth(index, &layer, &startDepth);
-    if (texture->isCPUAccessible() && index.getType() != gl::TextureType::_2DMultisample &&
+
+    if (intendedInternalFormat.compressed)
+    {
+        return InitializeCompressedTextureContents(context, texture, textureObjFormat, index, layer,
+                                                   startDepth);
+    }
+    else if (texture->isCPUAccessible() && index.getType() != gl::TextureType::_2DMultisample &&
              index.getType() != gl::TextureType::_2DMultisampleArray && !forceGPUInitialization)
     {
         const angle::Format &dstFormat = angle::Format::Get(textureObjFormat.actualFormatId);
@@ -418,11 +424,6 @@ bool GetCompressedBufferSizeAndRowLengthForTextureWithFormat(const TextureRef &t
             }
         }
     }
-    else if (intendedInternalFormat.compressed)
-    {
-        return InitializeCompressedTextureContents(context, texture, textureObjFormat, index, layer,
-                                                   startDepth);
-    }
     else
     {
         ANGLE_TRY(InitializeTextureContentsGPU(context, texture, textureObjFormat, index,
@@ -1251,9 +1252,17 @@ bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
             case 5:
                 family = MTLGPUFamilyApple5;
                 break;
-#    if TARGET_OS_IOS || TARGET_OS_OSX
+                
+#    if TARGET_OS_IOS || (TARGET_OS_OSX && __MAC_OS_X_VERSION_MAX_ALLOWED >= 10160)
             case 6:
+                if (@available(ios 14.0, macOS 10.15, *))
+                {
                     family = MTLGPUFamilyApple6;
+                }
+                else
+                {
+                    return false;
+                }
                 break;
 #    endif
             default:
diff --git a/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
new file mode 100644
index 0000000..da7457c
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
@@ -0,0 +1,76 @@
+#!/usr/bin/python
+# Copyright 2021 The ANGLE Project Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# create_mtl_internal_shaders.py:
+#   Script to compile a metalLib into NSData, for including the compilded
+#       library in the ANGLE dylib.
+
+import os
+import sys
+import json
+from datetime import datetime
+
+sys.path.append('../..')
+
+template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
+// Generated by {script_name}
+//
+// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+"""
+
+
+# Convert content of a file to byte array and store in a header file.
+# variable_name: name of C++ variable that will hold the file content as byte array.
+# filename: the file whose content will be converted to C++ byte array.
+# dest_src_file: destination header file that will contain the byte array.
+def append_file_as_byte_array_string(variable_name, filename, dest_src_file):
+    string = '// Generated from {0}:\n'.format(filename)
+    string += 'constexpr uint8_t {0}[]={{\n'.format(variable_name)
+    bytes_ = open(filename, "rb").read()
+    for byte in bytes_:
+        string += '0x{:02x}'.format(byte) + ", "
+    string += "\n};\n"
+    with open(dest_src_file, "a") as out_file:
+        out_file.write(string)
+
+
+# Compile metal shader.
+# compiled_file: The compiled metallib
+# variable_name: name of C++ variable that will hold the compiled binary data as a C array.
+# additional_flags: additional shader compiler flags
+# src_files: metal source files
+def gen_precompiled_shaders(compiled_file, variable_name, output_file):
+    append_file_as_byte_array_string(variable_name, compiled_file, output_file)
+    os.system('echo "constexpr size_t {0}_len=sizeof({0});" >> \"{1}\"'.format(
+        variable_name, output_file))
+
+
+def main():
+    input_file = sys.argv[1]
+    output_file = sys.argv[2]
+    os.chdir(sys.path[0])
+
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=sys.argv[0], copyright_year=datetime.today().year)
+
+    # -------- Compile shaders -----------
+    # boiler plate code
+    os.system("echo \"{0}\" > \"{1}\"".format(boilerplate_code, output_file))
+    os.system(
+        'echo "// Compiled binary for Metal default shaders.\n\n" >>  \"{0}\"'.format(output_file))
+    os.system('echo "#include <TargetConditionals.h>\n\n" >>  \"{0}\"'.format(output_file))
+
+    os.system('echo "// clang-format off" >> \"{0}\"'.format(output_file))
+
+    gen_precompiled_shaders(input_file, 'gMetalBinaryShaders', output_file)
+
+    os.system('echo "// clang-format on" >> \"{0}\"'.format(output_file))
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
index 1818eec..ca3b013 100644
--- a/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
+++ b/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
@@ -61,6 +61,10 @@ def find_clang():
                          'Release+Asserts', 'bin', binary)
 
     if not os.path.isfile(clang):
+        xcrun_clang = subprocess.run(["xcrun", "-f", binary], stdout=subprocess.PIPE, text=True)
+        if xcrun_clang.returncode == 0:
+            clang = xcrun_clang.stdout.strip()
+    if (not os.path.isfile(clang)):
         raise Exception('Cannot find clang')
 
     return clang
@@ -135,6 +139,13 @@ def main():
         out_file.write(')";\n')
         out_file.close()
 
+    with open('mtl_default_shaders_src_autogen.metal', 'wt') as out_file:
+        out_file.write(boilerplate_code)
+        out_file.write('\n')
+        out_file.write('// Metal version of combined Metal default shaders.\n\n')
+        out_file.write(final_combined_src_string.decode("utf-8"))
+        out_file.close()
+
     os.remove(temp_fname)
 
 
diff --git a/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.metal b/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.metal
new file mode 100644
index 0000000..ae5780d
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.metal
@@ -0,0 +1,3394 @@
+// GENERATED FILE - DO NOT EDIT.
+// Generated by gen_mtl_internal_shaders.py
+//
+// Copyright 2020 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// Metal version of combined Metal default shaders.
+
+# 1 "temp_master_source.metal"
+# 1 "<built-in>" 1
+# 1 "<built-in>" 3
+# 415 "<built-in>" 3
+# 1 "<command line>" 1
+# 1 "<built-in>" 2
+# 1 "temp_master_source.metal" 2
+# 1 "./blit.metal" 1
+
+
+
+
+
+
+
+# 1 "./common.h" 1
+# 13 "./common.h"
+# include <simd/simd.h>
+# include <metal_stdlib>
+
+
+# 1 "./constants.h" 1
+# 11 "./constants.h"
+namespace rx
+{
+namespace mtl_shader
+{
+
+enum
+{
+    kTextureType2D = 0,
+    kTextureType2DMultisample = 1,
+    kTextureType2DArray = 2,
+    kTextureTypeCube = 3,
+    kTextureType3D = 4,
+    kTextureTypeCount = 5,
+};
+
+
+
+
+}
+}
+# 18 "./common.h" 2
+
+
+
+
+
+
+
+using namespace metal;
+
+
+
+constant uint32_t kNumColorOutputs [[function_constant(0)]];
+constant bool kColorOutputAvailable0 = kNumColorOutputs > 0;
+constant bool kColorOutputAvailable1 = kNumColorOutputs > 1;
+constant bool kColorOutputAvailable2 = kNumColorOutputs > 2;
+constant bool kColorOutputAvailable3 = kNumColorOutputs > 3;
+
+namespace rx
+{
+namespace mtl_shader
+{
+
+
+constant float2 gCorners[3] = {float2(-1.0f, -1.0f), float2(3.0f, -1.0f), float2(-1.0f, 3.0f)};
+
+template <typename T>
+struct MultipleColorOutputs
+{
+    vec<T, 4> color0 [[color(0), function_constant(kColorOutputAvailable0)]];
+    vec<T, 4> color1 [[color(1), function_constant(kColorOutputAvailable1)]];
+    vec<T, 4> color2 [[color(2), function_constant(kColorOutputAvailable2)]];
+    vec<T, 4> color3 [[color(3), function_constant(kColorOutputAvailable3)]];
+};
+# 61 "./common.h"
+template <typename T>
+static inline MultipleColorOutputs<T> toMultipleColorOutputs(vec<T, 4> color)
+{
+    MultipleColorOutputs<T> re;
+
+    do { if (kColorOutputAvailable0) { re.color0 = color; } } while (0);
+    do { if (kColorOutputAvailable1) { re.color1 = color; } } while (0);
+    do { if (kColorOutputAvailable2) { re.color2 = color; } } while (0);
+    do { if (kColorOutputAvailable3) { re.color3 = color; } } while (0);
+
+    return re;
+}
+
+static inline float3 cubeTexcoords(float2 texcoords, int face)
+{
+    texcoords = 2.0 * texcoords - 1.0;
+    switch (face)
+    {
+        case 0:
+            return float3(1.0, -texcoords.y, -texcoords.x);
+        case 1:
+            return float3(-1.0, -texcoords.y, texcoords.x);
+        case 2:
+            return float3(texcoords.x, 1.0, texcoords.y);
+        case 3:
+            return float3(texcoords.x, -1.0, -texcoords.y);
+        case 4:
+            return float3(texcoords.x, -texcoords.y, 1.0);
+        case 5:
+            return float3(-texcoords.x, -texcoords.y, -1.0);
+    }
+    return float3(texcoords, 0);
+}
+
+template <typename T>
+static inline vec<T, 4> resolveTextureMS(texture2d_ms<T> srcTexture, uint2 coords)
+{
+    uint samples = srcTexture.get_num_samples();
+
+    vec<T, 4> output(0);
+
+    for (uint sample = 0; sample < samples; ++sample)
+    {
+        output += srcTexture.read(coords, sample);
+    }
+
+    output = output / samples;
+
+    return output;
+}
+
+static inline float4 sRGBtoLinear(float4 color)
+{
+    float3 linear1 = color.rgb / 12.92;
+    float3 linear2 = pow((color.rgb + float3(0.055)) / 1.055, 2.4);
+    float3 factor = float3(color.rgb <= float3(0.04045));
+    float4 linear = float4(factor * linear1 + float3(1.0 - factor) * linear2, color.a);
+
+    return linear;
+}
+
+static inline float linearToSRGB(float color)
+{
+    if (color <= 0.0f)
+        return 0.0f;
+    else if (color < 0.0031308f)
+        return 12.92f * color;
+    else if (color < 1.0f)
+        return 1.055f * pow(color, 0.41666f) - 0.055f;
+    else
+        return 1.0f;
+}
+
+static inline float4 linearToSRGB(float4 color)
+{
+    return float4(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b), color.a);
+}
+
+template <typename Short>
+static inline Short bytesToShort(constant uchar *input, uint offset)
+{
+    Short inputLo = input[offset];
+    Short inputHi = input[offset + 1];
+
+    return inputLo | (inputHi << 8);
+}
+
+template <typename Int>
+static inline Int bytesToInt(constant uchar *input, uint offset)
+{
+    Int input0 = input[offset];
+    Int input1 = input[offset + 1];
+    Int input2 = input[offset + 2];
+    Int input3 = input[offset + 3];
+
+    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
+}
+
+template <typename Short>
+static inline void shortToBytes(Short val, uint offset, device uchar *output)
+{
+    ushort valUnsigned = as_type<ushort>(val);
+    output[offset] = valUnsigned & 0xff;
+    output[offset + 1] = (valUnsigned >> 8) & 0xff;
+}
+
+template <typename Int>
+static inline void intToBytes(Int val, uint offset, device uchar *output)
+{
+    uint valUnsigned = as_type<uint>(val);
+    output[offset] = valUnsigned & 0xff;
+    output[offset + 1] = (valUnsigned >> 8) & 0xff;
+    output[offset + 2] = (valUnsigned >> 16) & 0xff;
+    output[offset + 3] = (valUnsigned >> 24) & 0xff;
+}
+
+static inline void floatToBytes(float val, uint offset, device uchar *output)
+{
+    intToBytes(as_type<uint>(val), offset, output);
+}
+
+static inline void int24bitToBytes(uint val, uint offset, device uchar *output)
+{
+    output[offset] = val & 0xff;
+    output[offset + 1] = (val >> 8) & 0xff;
+    output[offset + 2] = (val >> 16) & 0xff;
+}
+
+template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
+static inline T getShiftedData(T input)
+{
+    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
+                  "T must have at least as many bits as inputBitCount + inputBitStart.");
+    const T mask = (1 << inputBitCount) - 1;
+    return (input >> inputBitStart) & mask;
+}
+
+template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
+static inline T shiftData(T input)
+{
+    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
+                  "T must have at least as many bits as inputBitCount + inputBitStart.");
+    const T mask = (1 << inputBitCount) - 1;
+    return (input & mask) << inputBitStart;
+}
+
+template <unsigned int inputBitCount, typename T>
+static inline float normalizedToFloat(T input)
+{
+    static_assert(inputBitCount <= (sizeof(T) * 8),
+                  "T must have more bits than or same bits as inputBitCount.");
+    static_assert(inputBitCount <= 23, "Only single precision is supported");
+
+    constexpr float inverseMax = 1.0f / ((1 << inputBitCount) - 1);
+    return input * inverseMax;
+}
+
+template <typename T>
+static inline float normalizedToFloat(T input)
+{
+    return normalizedToFloat<sizeof(T) * 8, T>(input);
+}
+
+template <>
+inline float normalizedToFloat(short input)
+{
+    constexpr float inverseMax = 1.0f / 0x7fff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <>
+inline float normalizedToFloat(int input)
+{
+    constexpr float inverseMax = 1.0f / 0x7fffffff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <>
+inline float normalizedToFloat(uint input)
+{
+    constexpr float inverseMax = 1.0f / 0xffffffff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <unsigned int outputBitCount, typename T>
+static inline T floatToNormalized(float input)
+{
+    static_assert(outputBitCount <= (sizeof(T) * 8),
+                  "T must have more bits than or same bits as inputBitCount.");
+    static_assert(outputBitCount <= 23, "Only single precision is supported");
+
+    return static_cast<T>(((1 << outputBitCount) - 1) * input + 0.5f);
+}
+
+template <typename T>
+static inline T floatToNormalized(float input)
+{
+    return floatToNormalized<sizeof(T) * 8, T>(input);
+}
+
+}
+}
+# 9 "./blit.metal" 2
+
+using namespace rx::mtl_shader;
+
+
+constant bool kPremultiplyAlpha [[function_constant(1)]];
+constant bool kUnmultiplyAlpha [[function_constant(2)]];
+constant int kSourceTextureType [[function_constant(3)]];
+constant int kSourceTexture2Type [[function_constant(4)]];
+
+constant bool kSourceTextureType2D = kSourceTextureType == kTextureType2D;
+constant bool kSourceTextureType2DArray = kSourceTextureType == kTextureType2DArray;
+constant bool kSourceTextureType2DMS = kSourceTextureType == kTextureType2DMultisample;
+constant bool kSourceTextureTypeCube = kSourceTextureType == kTextureTypeCube;
+constant bool kSourceTextureType3D = kSourceTextureType == kTextureType3D;
+
+constant bool kSourceTexture2Type2D = kSourceTexture2Type == kTextureType2D;
+constant bool kSourceTexture2Type2DArray = kSourceTexture2Type == kTextureType2DArray;
+constant bool kSourceTexture2Type2DMS = kSourceTexture2Type == kTextureType2DMultisample;
+constant bool kSourceTexture2TypeCube = kSourceTexture2Type == kTextureTypeCube;
+
+struct BlitParams
+{
+
+    float2 srcTexCoords[3];
+    int srcLevel;
+    int srcLayer;
+    bool dstFlipViewportX;
+    bool dstFlipViewportY;
+    bool dstLuminance;
+    uint8_t padding[13];
+};
+
+struct BlitVSOut
+{
+    float4 position [[position]];
+    float2 texCoords [[user(locn1)]];
+};
+
+vertex BlitVSOut blitVS(unsigned int vid [[vertex_id]], constant BlitParams &options [[buffer(0)]])
+{
+    BlitVSOut output;
+    output.position = float4(gCorners[vid], 0.0, 1.0);
+    output.texCoords = options.srcTexCoords[vid];
+
+    if (options.dstFlipViewportX)
+    {
+        output.position.x = -output.position.x;
+    }
+    if (!options.dstFlipViewportY)
+    {
+
+
+        output.position.y = -output.position.y;
+    }
+
+    return output;
+}
+
+template <typename SrcTexture2d>
+static uint2 getImageCoords(SrcTexture2d srcTexture, float2 texCoords)
+{
+    uint2 dimens(srcTexture.get_width(), srcTexture.get_height());
+    uint2 coords = uint2(texCoords * float2(dimens));
+
+    return coords;
+}
+
+template <typename T>
+static inline vec<T, 4> blitSampleTextureMS(texture2d_ms<T> srcTexture, float2 texCoords)
+{
+    uint2 coords = getImageCoords(srcTexture, texCoords);
+    return resolveTextureMS(srcTexture, coords);
+}
+
+template <typename T>
+static inline vec<T, 4> blitSampleTexture3D(texture3d<T> srcTexture,
+                                            sampler textureSampler,
+                                            float2 texCoords,
+                                            constant BlitParams &options)
+{
+    uint depth = srcTexture.get_depth(options.srcLevel);
+    float zCoord = (float(options.srcLayer) + 0.5) / float(depth);
+
+    return srcTexture.sample(textureSampler, float3(texCoords, zCoord), level(options.srcLevel));
+}
+# 112 "./blit.metal"
+template <typename T>
+static inline vec<T, 4> blitReadTexture(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    vec<T, 4> output;
+
+    switch (kSourceTextureType)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, input.texCoords, level(options.srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, input.texCoords, options.srcLayer,
+                                              level(options.srcLevel));
+            break;
+        case kTextureType2DMultisample:
+            output = blitSampleTextureMS(srcTexture2dMS, input.texCoords);
+            break;
+        case kTextureTypeCube:
+            output = srcTextureCube.sample(textureSampler,
+                                           cubeTexcoords(input.texCoords, options.srcLayer),
+                                           level(options.srcLevel));
+            break;
+        case kTextureType3D:
+            output = blitSampleTexture3D(srcTexture3d, textureSampler, input.texCoords, options);
+            break;
+    }
+
+    if (kPremultiplyAlpha)
+    {
+        output.xyz *= output.a;
+    }
+    else if (kUnmultiplyAlpha)
+    {
+        if (output.a != 0.0)
+        {
+            output.xyz /= output.a;
+        }
+    }
+
+    if (options.dstLuminance)
+    {
+        output.g = output.b = output.r;
+    }
+
+    return output;
+}
+
+template <typename T>
+static inline MultipleColorOutputs<T> blitFS(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    vec<T, 4> output = blitReadTexture(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+
+    return toMultipleColorOutputs(output);
+}
+
+fragment MultipleColorOutputs<float> blitFloatFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+fragment MultipleColorOutputs<int> blitIntFS(BlitVSOut input [[stage_in]], texture2d<int> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<int> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<int> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<int> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<int> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+fragment MultipleColorOutputs<uint> blitUIntFS(BlitVSOut input [[stage_in]], texture2d<uint> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<uint> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<uint> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<uint> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<uint> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+
+fragment MultipleColorOutputs<uint> copyTextureFloatToUIntFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    float4 inputColor = blitReadTexture<>(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+    uint4 output = uint4(inputColor * float4(255.0));
+
+    return toMultipleColorOutputs(output);
+}
+
+
+struct FragmentDepthOut
+{
+    float depth [[depth(any)]];
+};
+
+static inline float sampleDepth(
+    texture2d<float> srcTexture2d [[function_constant(kSourceTextureType2D)]],
+    texture2d_array<float> srcTexture2dArray [[function_constant(kSourceTextureType2DArray)]],
+    texture2d_ms<float> srcTexture2dMS [[function_constant(kSourceTextureType2DMS)]],
+    texturecube<float> srcTextureCube [[function_constant(kSourceTextureTypeCube)]],
+    float2 texCoords,
+    constant BlitParams &options)
+{
+    float4 output;
+
+    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
+
+    switch (kSourceTextureType)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, texCoords, level(options.srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, texCoords, options.srcLayer,
+                                              level(options.srcLevel));
+            break;
+        case kTextureType2DMultisample:
+
+            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
+            break;
+        case kTextureTypeCube:
+            output =
+                srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, options.srcLayer),
+                                      level(options.srcLevel));
+            break;
+    }
+
+    return output.r;
+}
+
+fragment FragmentDepthOut blitDepthFS(BlitVSOut input [[stage_in]],
+                                      texture2d<float> srcTexture2d
+                                      [[texture(0), function_constant(kSourceTextureType2D)]],
+                                      texture2d_array<float> srcTexture2dArray
+                                      [[texture(0), function_constant(kSourceTextureType2DArray)]],
+                                      texture2d_ms<float> srcTexture2dMS
+                                      [[texture(0), function_constant(kSourceTextureType2DMS)]],
+                                      texturecube<float> srcTextureCube
+                                      [[texture(0), function_constant(kSourceTextureTypeCube)]],
+                                      constant BlitParams &options [[buffer(0)]])
+{
+    FragmentDepthOut re;
+
+    re.depth = sampleDepth(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                           input.texCoords, options);
+
+    return re;
+}
+
+static inline uint32_t sampleStencil(
+    texture2d<uint32_t> srcTexture2d [[function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcTexture2dArray [[function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcTexture2dMS [[function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcTextureCube [[function_constant(kSourceTexture2TypeCube)]],
+    float2 texCoords,
+    int srcLevel,
+    int srcLayer)
+{
+    uint4 output;
+    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
+
+    switch (kSourceTexture2Type)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, texCoords, level(srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, texCoords, srcLayer, level(srcLevel));
+            break;
+        case kTextureType2DMultisample:
+
+            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
+            break;
+        case kTextureTypeCube:
+            output = srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, srcLayer),
+                                           level(srcLevel));
+            break;
+    }
+
+    return output.r;
+}
+
+
+struct BlitStencilToBufferParams
+{
+    float2 srcStartTexCoords;
+    float2 srcTexCoordSteps;
+    int srcLevel;
+    int srcLayer;
+
+    uint2 dstSize;
+    uint dstBufferRowPitch;
+
+    bool resolveMS;
+};
+
+kernel void blitStencilToBufferCS(ushort2 gIndices [[thread_position_in_grid]],
+                                  texture2d<uint32_t> srcTexture2d
+                                  [[texture(1), function_constant(kSourceTexture2Type2D)]],
+                                  texture2d_array<uint32_t> srcTexture2dArray
+                                  [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+                                  texture2d_ms<uint32_t> srcTexture2dMS
+                                  [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+                                  texturecube<uint32_t> srcTextureCube
+                                  [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+                                  constant BlitStencilToBufferParams &options [[buffer(0)]],
+                                  device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.dstSize.x || gIndices.y >= options.dstSize.y)
+    {
+        return;
+    }
+
+    float2 srcTexCoords = options.srcStartTexCoords + float2(gIndices) * options.srcTexCoordSteps;
+
+    if (kSourceTexture2Type == kTextureType2DMultisample && !options.resolveMS)
+    {
+        uint samples = srcTexture2dMS.get_num_samples();
+        uint2 imageCoords = getImageCoords(srcTexture2dMS, srcTexCoords);
+        uint bufferOffset = options.dstBufferRowPitch * gIndices.y + samples * gIndices.x;
+
+        for (uint sample = 0; sample < samples; ++sample)
+        {
+            uint stencilPerSample = srcTexture2dMS.read(imageCoords, sample).r;
+            buffer[bufferOffset + sample] = static_cast<uchar>(stencilPerSample);
+        }
+    }
+    else
+    {
+        uint32_t stencil =
+            sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                          srcTexCoords, options.srcLevel, options.srcLayer);
+
+        buffer[options.dstBufferRowPitch * gIndices.y + gIndices.x] = static_cast<uchar>(stencil);
+    }
+}
+
+
+#if __METAL_VERSION__ >= 210
+
+struct FragmentStencilOut
+{
+    uint32_t stencil [[stencil]];
+};
+
+struct FragmentDepthStencilOut
+{
+    float depth [[depth(any)]];
+    uint32_t stencil [[stencil]];
+};
+
+fragment FragmentStencilOut blitStencilFS(
+    BlitVSOut input [[stage_in]],
+    texture2d<uint32_t> srcTexture2d [[texture(1), function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcTexture2dArray
+    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcTexture2dMS
+    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcTextureCube [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+    constant BlitParams &options [[buffer(0)]])
+{
+    FragmentStencilOut re;
+
+    re.stencil = sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                               input.texCoords, options.srcLevel, options.srcLayer);
+
+    return re;
+}
+
+fragment FragmentDepthStencilOut blitDepthStencilFS(
+    BlitVSOut input [[stage_in]],
+
+    texture2d<float> srcDepthTexture2d [[texture(0), function_constant(kSourceTextureType2D)]],
+    texture2d_array<float> srcDepthTexture2dArray
+    [[texture(0), function_constant(kSourceTextureType2DArray)]],
+    texture2d_ms<float> srcDepthTexture2dMS
+    [[texture(0), function_constant(kSourceTextureType2DMS)]],
+    texturecube<float> srcDepthTextureCube
+    [[texture(0), function_constant(kSourceTextureTypeCube)]],
+
+
+    texture2d<uint32_t> srcStencilTexture2d
+    [[texture(1), function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcStencilTexture2dArray
+    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcStencilTexture2dMS
+    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcStencilTextureCube
+    [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+
+    constant BlitParams &options [[buffer(0)]])
+{
+    FragmentDepthStencilOut re;
+
+    re.depth = sampleDepth(srcDepthTexture2d, srcDepthTexture2dArray, srcDepthTexture2dMS,
+                           srcDepthTextureCube, input.texCoords, options);
+    re.stencil =
+        sampleStencil(srcStencilTexture2d, srcStencilTexture2dArray, srcStencilTexture2dMS,
+                      srcStencilTextureCube, input.texCoords, options.srcLevel, options.srcLayer);
+    return re;
+}
+#endif
+# 2 "temp_master_source.metal" 2
+# 1 "./clear.metal" 1
+# 10 "./clear.metal"
+using namespace rx::mtl_shader;
+
+struct ClearParams
+{
+    float4 clearColor;
+    float clearDepth;
+};
+
+vertex float4 clearVS(unsigned int vid [[ vertex_id ]],
+                      constant ClearParams &clearParams [[buffer(0)]])
+{
+    return float4(gCorners[vid], clearParams.clearDepth, 1.0);
+}
+
+fragment MultipleColorOutputs<float> clearFloatFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(clearParams.clearColor);
+}
+
+fragment MultipleColorOutputs<int> clearIntFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(as_type<int4>(clearParams.clearColor));
+}
+
+fragment MultipleColorOutputs<uint> clearUIntFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(as_type<uint4>(clearParams.clearColor));
+}
+# 3 "temp_master_source.metal" 2
+# 1 "./gen_indices.metal" 1
+
+
+
+
+
+
+
+
+using namespace rx::mtl_shader;
+
+
+constant bool kSourceBufferAligned[[function_constant(100)]];
+constant bool kSourceIndexIsU8[[function_constant(200)]];
+constant bool kSourceIndexIsU16[[function_constant(300)]];
+constant bool kSourceIndexIsU32[[function_constant(400)]];
+constant bool kSourceBufferUnaligned = !kSourceBufferAligned;
+constant bool kUseSourceBufferU8 = kSourceIndexIsU8 || kSourceBufferUnaligned;
+constant bool kUseSourceBufferU16 = kSourceIndexIsU16 && kSourceBufferAligned;
+constant bool kUseSourceBufferU32 = kSourceIndexIsU32 && kSourceBufferAligned;
+
+struct IndexConversionParams
+{
+    uint32_t srcOffset;
+    uint32_t indexCount;
+    bool primitiveRestartEnabled;
+};
+
+
+
+inline ushort getIndexAligned(constant ushort *inputAligned, uint offset, uint idx)
+{
+    return inputAligned[offset / 2 + idx];
+}
+inline uint getIndexAligned(constant uint *inputAligned, uint offset, uint idx)
+{
+    return inputAligned[offset / 4 + idx];
+}
+inline uchar getIndexAligned(constant uchar *input, uint offset, uint idx)
+{
+    return input[offset + idx];
+}
+inline ushort getIndexUnalignedU16(constant uchar *input, uint offset, uint idx)
+{
+    ushort inputLo = input[offset + 2 * idx];
+    ushort inputHi = input[offset + 2 * idx + 1];
+
+    return inputLo | (inputHi << 8);
+}
+inline uint getIndexUnalignedU32(constant uchar *input, uint offset, uint idx)
+{
+    uint input0 = input[offset + 4 * idx];
+    uint input1 = input[offset + 4 * idx + 1];
+    uint input2 = input[offset + 4 * idx + 2];
+    uint input3 = input[offset + 4 * idx + 3];
+
+    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
+}
+
+kernel void convertIndexU8ToU16(uint idx [[thread_position_in_grid]],
+                                constant IndexConversionParams &options [[buffer(0)]],
+                                constant uchar *input [[buffer(1)]],
+                                device ushort *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uchar value = getIndexAligned(input, options.srcOffset, idx);
+
+    if (options.primitiveRestartEnabled && value == 0xff)
+    {
+        output[idx] = 0xffff;
+    }
+    else
+    {
+        output[idx] = value;
+    }
+}
+
+kernel void convertIndexU16(uint idx [[thread_position_in_grid]],
+                            constant IndexConversionParams &options [[buffer(0)]],
+                            constant uchar *input
+                            [[buffer(1), function_constant(kSourceBufferUnaligned)]],
+                            constant ushort *inputAligned
+                            [[buffer(1), function_constant(kSourceBufferAligned)]],
+                            device ushort *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    ushort value;
+    if (kSourceBufferAligned)
+    {
+        value = getIndexAligned(inputAligned, options.srcOffset, idx);
+    }
+    else
+    {
+        value = getIndexUnalignedU16(input, options.srcOffset, idx);
+    }
+    output[idx] = value;
+}
+
+kernel void convertIndexU32(uint idx [[thread_position_in_grid]],
+                            constant IndexConversionParams &options [[buffer(0)]],
+                            constant uchar *input
+                            [[buffer(1), function_constant(kSourceBufferUnaligned)]],
+                            constant uint *inputAligned
+                            [[buffer(1), function_constant(kSourceBufferAligned)]],
+                            device uint *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uint value;
+    if (kSourceBufferAligned)
+    {
+        value = getIndexAligned(inputAligned, options.srcOffset, idx);
+    }
+    else
+    {
+        value = getIndexUnalignedU32(input, options.srcOffset, idx);
+    }
+    output[idx] = value;
+}
+
+struct IndexFromArrayParams
+{
+    uint firstVertex;
+
+    uint vertexCount;
+};
+
+
+kernel void genTriFanIndicesFromArray(uint idx [[thread_position_in_grid]],
+                                      constant IndexFromArrayParams &options [[buffer(0)]],
+                                      device uint *output [[buffer(2)]])
+{
+    if (idx >= options.vertexCount) { return; };
+
+    uint vertexIdx = options.firstVertex + 2 + idx;
+
+    output[3 * idx] = options.firstVertex;
+    output[3 * idx + 1] = vertexIdx - 1;
+    output[3 * idx + 2] = vertexIdx;
+}
+
+inline uint getIndexU32(uint offset,
+                        uint idx,
+                        constant uchar *inputU8 [[function_constant(kUseSourceBufferU8)]],
+                        constant ushort *inputU16 [[function_constant(kUseSourceBufferU16)]],
+                        constant uint *inputU32 [[function_constant(kUseSourceBufferU32)]])
+{
+    if (kUseSourceBufferU8)
+    {
+        if (kSourceIndexIsU16)
+        {
+            return getIndexUnalignedU16(inputU8, offset, idx);
+        }
+        else if (kSourceIndexIsU32)
+        {
+            return getIndexUnalignedU32(inputU8, offset, idx);
+        }
+        return getIndexAligned(inputU8, offset, idx);
+    }
+    else if (kUseSourceBufferU16)
+    {
+        return getIndexAligned(inputU16, offset, idx);
+    }
+    else if (kUseSourceBufferU32)
+    {
+        return getIndexAligned(inputU32, offset, idx);
+    }
+    return 0;
+}
+
+
+
+
+kernel void genTriFanIndicesFromElements(uint idx [[thread_position_in_grid]],
+                                         constant IndexConversionParams &options [[buffer(0)]],
+                                         constant uchar *inputU8
+                                         [[buffer(1), function_constant(kUseSourceBufferU8)]],
+                                         constant ushort *inputU16
+                                         [[buffer(1), function_constant(kUseSourceBufferU16)]],
+                                         constant uint *inputU32
+                                         [[buffer(1), function_constant(kUseSourceBufferU32)]],
+                                         device uint *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uint elemIdx = 2 + idx;
+
+    output[3 * idx] = getIndexU32(options.srcOffset, 0, inputU8, inputU16, inputU32);
+    output[3 * idx + 1] = getIndexU32(options.srcOffset, elemIdx - 1, inputU8, inputU16, inputU32);
+    output[3 * idx + 2] = getIndexU32(options.srcOffset, elemIdx, inputU8, inputU16, inputU32);
+}
+
+
+kernel void genLineLoopIndicesFromArray(uint idx [[thread_position_in_grid]],
+                                        constant IndexFromArrayParams &options [[buffer(0)]],
+                                        device uint *output [[buffer(2)]])
+{
+    uint totalIndices = options.vertexCount + 1;
+    if (idx >= totalIndices) { return; };
+
+    output[idx] = options.firstVertex + idx % options.vertexCount;
+}
+
+
+
+kernel void genLineLoopIndicesFromElements(uint idx [[thread_position_in_grid]],
+                                           constant IndexConversionParams &options [[buffer(0)]],
+                                           constant uchar *inputU8
+                                           [[buffer(1), function_constant(kUseSourceBufferU8)]],
+                                           constant ushort *inputU16
+                                           [[buffer(1), function_constant(kUseSourceBufferU16)]],
+                                           constant uint *inputU32
+                                           [[buffer(1), function_constant(kUseSourceBufferU32)]],
+                                           device uint *output [[buffer(2)]])
+{
+    uint totalTargetIndices = options.indexCount + 1;
+    if (idx >= totalTargetIndices) { return; };
+
+    output[idx] =
+        getIndexU32(options.srcOffset, idx % options.indexCount, inputU8, inputU16, inputU32);
+}
+# 4 "temp_master_source.metal" 2
+# 1 "./gen_mipmap.metal" 1
+
+
+
+
+
+
+
+
+using namespace rx::mtl_shader;
+# 31 "./gen_mipmap.metal"
+struct GenMipParams
+{
+    uint srcLevel;
+    uint numMipLevelsToGen;
+    bool sRGB;
+};
+
+
+
+kernel void generate3DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                              ushort3 gIndices [[thread_position_in_grid]],
+                              texture3d<float> srcTexture [[texture(0)]],
+                              texture3d<float, access::write> dstMip1 [[texture(1)]],
+                              texture3d<float, access::write> dstMip2 [[texture(2)]],
+                              texture3d<float, access::write> dstMip3 [[texture(3)]],
+                              texture3d<float, access::write> dstMip4 [[texture(4)]],
+                              constant GenMipParams &options [[buffer(0)]])
+{
+    ushort3 mipSize = ushort3(dstMip1.get_width(), dstMip1.get_height(), dstMip1.get_depth());
+    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y && gIndices.z < mipSize.z;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+
+
+    threadgroup float sR[(8 * 8 * 8)];
+    threadgroup float sG[(8 * 8 * 8)];
+    threadgroup float sB[(8 * 8 * 8)];
+    threadgroup float sA[(8 * 8 * 8)];
+
+
+    float4 texel1;
+    if (validThread)
+    {
+        float3 texCoords = (float3(gIndices) + float3(0.5, 0.5, 0.5)) / float3(mipSize);
+        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
+
+
+        dstMip1.write(texel1, gIndices);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+
+
+    if (options.sRGB)
+    {
+        texel1 = linearToSRGB(texel1);
+    }
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x49) == 0)
+    {
+        bool3 atEdge = gIndices == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.z) ? (texel1) : (float4(sR[lIndex + (8 * 8)], sG[lIndex + (8 * 8)], sB[lIndex + (8 * 8)], sA[lIndex + (8 * 8)]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + ((8 * 8) + 1)], sG[lIndex + ((8 * 8) + 1)], sB[lIndex + ((8 * 8) + 1)], sA[lIndex + ((8 * 8) + 1)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + ((8 * 8) + 8)], sG[lIndex + ((8 * 8) + 8)], sB[lIndex + ((8 * 8) + 8)], sA[lIndex + ((8 * 8) + 8)]));
+
+
+        float4 texel8 =
+            (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + ((8 * 8) + 8 + 1)], sG[lIndex + ((8 * 8) + 8 + 1)], sB[lIndex + ((8 * 8) + 8 + 1)], sA[lIndex + ((8 * 8) + 8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0xdb) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort3(1));
+        bool3 atEdge = (gIndices >> 1) == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (2 * 8)], sG[lIndex + (2 * 8)], sB[lIndex + (2 * 8)], sA[lIndex + (2 * 8)]));
+
+        float4 texel4 =
+            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (2 * (8 * 8))], sG[lIndex + (2 * (8 * 8))], sB[lIndex + (2 * (8 * 8))], sA[lIndex + (2 * (8 * 8))]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (2 * (8 * 8) + 2)], sG[lIndex + (2 * (8 * 8) + 2)], sB[lIndex + (2 * (8 * 8) + 2)], sA[lIndex + (2 * (8 * 8) + 2)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8)], sG[lIndex + (2 * (8 * 8) + 2 * 8)], sB[lIndex + (2 * (8 * 8) + 2 * 8)], sA[lIndex + (2 * (8 * 8) + 2 * 8)]));
+
+
+
+        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sG[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sB[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sA[lIndex + (2 * (8 * 8) + 2 * 8 + 2)]));
+
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1ff) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort3(1));
+        bool3 atEdge = (gIndices >> 2) == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (4 * 8)], sG[lIndex + (4 * 8)], sB[lIndex + (4 * 8)], sA[lIndex + (4 * 8)]));
+
+        float4 texel4 =
+            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (4 * (8 * 8))], sG[lIndex + (4 * (8 * 8))], sB[lIndex + (4 * (8 * 8))], sA[lIndex + (4 * (8 * 8))]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (4 * (8 * 8) + 4)], sG[lIndex + (4 * (8 * 8) + 4)], sB[lIndex + (4 * (8 * 8) + 4)], sA[lIndex + (4 * (8 * 8) + 4)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8)], sG[lIndex + (4 * (8 * 8) + 4 * 8)], sB[lIndex + (4 * (8 * 8) + 4 * 8)], sA[lIndex + (4 * (8 * 8) + 4 * 8)]));
+
+
+
+        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sG[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sB[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sA[lIndex + (4 * (8 * 8) + 4 * 8 + 4)]));
+
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
+    }
+}
+
+kernel void generate2DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                              ushort2 gIndices [[thread_position_in_grid]],
+                              texture2d<float> srcTexture [[texture(0)]],
+                              texture2d<float, access::write> dstMip1 [[texture(1)]],
+                              texture2d<float, access::write> dstMip2 [[texture(2)]],
+                              texture2d<float, access::write> dstMip3 [[texture(3)]],
+                              texture2d<float, access::write> dstMip4 [[texture(4)]],
+                              constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mipSize =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+
+    float4 texel1;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices) + float2(0.5, 0.5)) / float2(mipSize);
+        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+
+
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x09) == 0)
+    {
+        bool2 atEdge = gIndices == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1b) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices >> 1) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 2 * 8], sG[lIndex + 2 * 8], sB[lIndex + 2 * 8], sA[lIndex + 2 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x3f) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices >> 2) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 4 * 8], sG[lIndex + 4 * 8], sB[lIndex + 4 * 8], sA[lIndex + 4 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
+    }
+}
+
+template <typename TextureTypeR, typename TextureTypeW>
+static __attribute__((always_inline)) void generateCubeOr2DArray2ndAndMoreMipmaps(
+    uint lIndex,
+    ushort3 gIndices,
+    TextureTypeR srcTexture,
+    TextureTypeW dstMip2,
+    TextureTypeW dstMip3,
+    TextureTypeW dstMip4,
+    ushort2 mip1Size,
+    float4 mip1Texel,
+    threadgroup float *sR,
+    threadgroup float *sG,
+    threadgroup float *sB,
+    threadgroup float *sA,
+    constant GenMipParams &options)
+{
+    ushort2 mipSize = mip1Size;
+    float4 texel1 = mip1Texel;
+
+
+
+
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x09) == 0)
+    {
+        bool2 atEdge = gIndices.xy == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 1, gIndices.z);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1b) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices.xy >> 1) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 2 * 8], sG[lIndex + 2 * 8], sB[lIndex + 2 * 8], sA[lIndex + 2 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 2, gIndices.z);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x3f) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices.xy >> 2) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 4 * 8], sG[lIndex + 4 * 8], sB[lIndex + 4 * 8], sA[lIndex + 4 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 3, gIndices.z);
+    }
+}
+
+kernel void generateCubeMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                                ushort3 gIndices [[thread_position_in_grid]],
+                                texturecube<float> srcTexture [[texture(0)]],
+                                texturecube<float, access::write> dstMip1 [[texture(1)]],
+                                texturecube<float, access::write> dstMip2 [[texture(2)]],
+                                texturecube<float, access::write> dstMip3 [[texture(3)]],
+                                texturecube<float, access::write> dstMip4 [[texture(4)]],
+                                constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mip1Size =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mip1Size.x && gIndices.y < mip1Size.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+    float4 mip1Texel;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices.xy) + float2(0.5, 0.5)) / float2(mip1Size);
+        mip1Texel = srcTexture.sample(textureSampler, cubeTexcoords(texCoords, int(gIndices.z)),
+                                      level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(mip1Texel) : mip1Texel), gIndices.xy, gIndices.z);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+    generateCubeOr2DArray2ndAndMoreMipmaps(lIndex, gIndices, srcTexture, dstMip2, dstMip3, dstMip4,
+                                           mip1Size, mip1Texel, sR, sG, sB, sA, options);
+}
+
+kernel void generate2DArrayMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                                   ushort3 gIndices [[thread_position_in_grid]],
+                                   texture2d_array<float> srcTexture [[texture(0)]],
+                                   texture2d_array<float, access::write> dstMip1 [[texture(1)]],
+                                   texture2d_array<float, access::write> dstMip2 [[texture(2)]],
+                                   texture2d_array<float, access::write> dstMip3 [[texture(3)]],
+                                   texture2d_array<float, access::write> dstMip4 [[texture(4)]],
+                                   constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mip1Size =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mip1Size.x && gIndices.y < mip1Size.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+    float4 mip1Texel;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices.xy) + float2(0.5, 0.5)) / float2(mip1Size);
+        mip1Texel =
+            srcTexture.sample(textureSampler, texCoords, gIndices.z, level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(mip1Texel) : mip1Texel), gIndices.xy, gIndices.z);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+    generateCubeOr2DArray2ndAndMoreMipmaps(lIndex, gIndices, srcTexture, dstMip2, dstMip3, dstMip4,
+                                           mip1Size, mip1Texel, sR, sG, sB, sA, options);
+}
+# 5 "temp_master_source.metal" 2
+# 1 "./copy_buffer.metal" 1
+# 12 "./copy_buffer.metal"
+#include <metal_pack>
+
+
+# 1 "./format_autogen.h" 1
+# 11 "./format_autogen.h"
+namespace rx
+{
+namespace mtl_shader
+{
+
+namespace FormatID
+{
+enum
+{
+    NONE,
+    D16_UNORM,
+    D24_UNORM_S8_UINT,
+    D24_UNORM_X8_UINT,
+    D32_FLOAT,
+    D32_FLOAT_S8X24_UINT,
+    D32_UNORM,
+    S8_UINT,
+    A16_FLOAT,
+    A1R5G5B5_UNORM,
+    A2R10G10B10_SINT_VERTEX,
+    A2R10G10B10_SNORM_VERTEX,
+    A2R10G10B10_SSCALED_VERTEX,
+    A2R10G10B10_UINT_VERTEX,
+    A2R10G10B10_UNORM_VERTEX,
+    A2R10G10B10_USCALED_VERTEX,
+    A32_FLOAT,
+    A8_UNORM,
+    ASTC_10x10_SRGB_BLOCK,
+    ASTC_10x10_UNORM_BLOCK,
+    ASTC_10x5_SRGB_BLOCK,
+    ASTC_10x5_UNORM_BLOCK,
+    ASTC_10x6_SRGB_BLOCK,
+    ASTC_10x6_UNORM_BLOCK,
+    ASTC_10x8_SRGB_BLOCK,
+    ASTC_10x8_UNORM_BLOCK,
+    ASTC_12x10_SRGB_BLOCK,
+    ASTC_12x10_UNORM_BLOCK,
+    ASTC_12x12_SRGB_BLOCK,
+    ASTC_12x12_UNORM_BLOCK,
+    ASTC_3x3x3_UNORM_BLOCK,
+    ASTC_3x3x3_UNORM_SRGB_BLOCK,
+    ASTC_4x3x3_UNORM_BLOCK,
+    ASTC_4x3x3_UNORM_SRGB_BLOCK,
+    ASTC_4x4_SRGB_BLOCK,
+    ASTC_4x4_UNORM_BLOCK,
+    ASTC_4x4x3_UNORM_BLOCK,
+    ASTC_4x4x3_UNORM_SRGB_BLOCK,
+    ASTC_4x4x4_UNORM_BLOCK,
+    ASTC_4x4x4_UNORM_SRGB_BLOCK,
+    ASTC_5x4_SRGB_BLOCK,
+    ASTC_5x4_UNORM_BLOCK,
+    ASTC_5x4x4_UNORM_BLOCK,
+    ASTC_5x4x4_UNORM_SRGB_BLOCK,
+    ASTC_5x5_SRGB_BLOCK,
+    ASTC_5x5_UNORM_BLOCK,
+    ASTC_5x5x4_UNORM_BLOCK,
+    ASTC_5x5x4_UNORM_SRGB_BLOCK,
+    ASTC_5x5x5_UNORM_BLOCK,
+    ASTC_5x5x5_UNORM_SRGB_BLOCK,
+    ASTC_6x5_SRGB_BLOCK,
+    ASTC_6x5_UNORM_BLOCK,
+    ASTC_6x5x5_UNORM_BLOCK,
+    ASTC_6x5x5_UNORM_SRGB_BLOCK,
+    ASTC_6x6_SRGB_BLOCK,
+    ASTC_6x6_UNORM_BLOCK,
+    ASTC_6x6x5_UNORM_BLOCK,
+    ASTC_6x6x5_UNORM_SRGB_BLOCK,
+    ASTC_6x6x6_UNORM_BLOCK,
+    ASTC_6x6x6_UNORM_SRGB_BLOCK,
+    ASTC_8x5_SRGB_BLOCK,
+    ASTC_8x5_UNORM_BLOCK,
+    ASTC_8x6_SRGB_BLOCK,
+    ASTC_8x6_UNORM_BLOCK,
+    ASTC_8x8_SRGB_BLOCK,
+    ASTC_8x8_UNORM_BLOCK,
+    B10G10R10A2_UNORM,
+    B4G4R4A4_UNORM,
+    B5G5R5A1_UNORM,
+    B5G6R5_UNORM,
+    B8G8R8A8_TYPELESS,
+    B8G8R8A8_TYPELESS_SRGB,
+    B8G8R8A8_UNORM,
+    B8G8R8A8_UNORM_SRGB,
+    B8G8R8X8_UNORM,
+    BC1_RGBA_UNORM_BLOCK,
+    BC1_RGBA_UNORM_SRGB_BLOCK,
+    BC1_RGB_UNORM_BLOCK,
+    BC1_RGB_UNORM_SRGB_BLOCK,
+    BC2_RGBA_UNORM_BLOCK,
+    BC2_RGBA_UNORM_SRGB_BLOCK,
+    BC3_RGBA_UNORM_BLOCK,
+    BC3_RGBA_UNORM_SRGB_BLOCK,
+    BC4_RED_SNORM_BLOCK,
+    BC4_RED_UNORM_BLOCK,
+    BC5_RG_SNORM_BLOCK,
+    BC5_RG_UNORM_BLOCK,
+    BC6H_RGB_SFLOAT_BLOCK,
+    BC6H_RGB_UFLOAT_BLOCK,
+    BC7_RGBA_UNORM_BLOCK,
+    BC7_RGBA_UNORM_SRGB_BLOCK,
+    EAC_R11G11_SNORM_BLOCK,
+    EAC_R11G11_UNORM_BLOCK,
+    EAC_R11_SNORM_BLOCK,
+    EAC_R11_UNORM_BLOCK,
+    ETC1_LOSSY_DECODE_R8G8B8_UNORM_BLOCK,
+    ETC1_R8G8B8_UNORM_BLOCK,
+    ETC2_R8G8B8A1_SRGB_BLOCK,
+    ETC2_R8G8B8A1_UNORM_BLOCK,
+    ETC2_R8G8B8A8_SRGB_BLOCK,
+    ETC2_R8G8B8A8_UNORM_BLOCK,
+    ETC2_R8G8B8_SRGB_BLOCK,
+    ETC2_R8G8B8_UNORM_BLOCK,
+    G8_B8R8_2PLANE_420_UNORM,
+    G8_B8_R8_3PLANE_420_UNORM,
+    L16A16_FLOAT,
+    L16_FLOAT,
+    L32A32_FLOAT,
+    L32_FLOAT,
+    L8A8_UNORM,
+    L8_UNORM,
+    PVRTC1_RGBA_2BPP_UNORM_BLOCK,
+    PVRTC1_RGBA_2BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGBA_4BPP_UNORM_BLOCK,
+    PVRTC1_RGBA_4BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGB_2BPP_UNORM_BLOCK,
+    PVRTC1_RGB_2BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGB_4BPP_UNORM_BLOCK,
+    PVRTC1_RGB_4BPP_UNORM_SRGB_BLOCK,
+    R10G10B10A2_SINT,
+    R10G10B10A2_SNORM,
+    R10G10B10A2_SSCALED,
+    R10G10B10A2_UINT,
+    R10G10B10A2_UNORM,
+    R10G10B10A2_USCALED,
+    R10G10B10X2_UNORM,
+    R11G11B10_FLOAT,
+    R16G16B16A16_FLOAT,
+    R16G16B16A16_SINT,
+    R16G16B16A16_SNORM,
+    R16G16B16A16_SSCALED,
+    R16G16B16A16_UINT,
+    R16G16B16A16_UNORM,
+    R16G16B16A16_USCALED,
+    R16G16B16_FLOAT,
+    R16G16B16_SINT,
+    R16G16B16_SNORM,
+    R16G16B16_SSCALED,
+    R16G16B16_UINT,
+    R16G16B16_UNORM,
+    R16G16B16_USCALED,
+    R16G16_FLOAT,
+    R16G16_SINT,
+    R16G16_SNORM,
+    R16G16_SSCALED,
+    R16G16_UINT,
+    R16G16_UNORM,
+    R16G16_USCALED,
+    R16_FLOAT,
+    R16_SINT,
+    R16_SNORM,
+    R16_SSCALED,
+    R16_UINT,
+    R16_UNORM,
+    R16_USCALED,
+    R32G32B32A32_FIXED,
+    R32G32B32A32_FLOAT,
+    R32G32B32A32_SINT,
+    R32G32B32A32_SNORM,
+    R32G32B32A32_SSCALED,
+    R32G32B32A32_UINT,
+    R32G32B32A32_UNORM,
+    R32G32B32A32_USCALED,
+    R32G32B32_FIXED,
+    R32G32B32_FLOAT,
+    R32G32B32_SINT,
+    R32G32B32_SNORM,
+    R32G32B32_SSCALED,
+    R32G32B32_UINT,
+    R32G32B32_UNORM,
+    R32G32B32_USCALED,
+    R32G32_FIXED,
+    R32G32_FLOAT,
+    R32G32_SINT,
+    R32G32_SNORM,
+    R32G32_SSCALED,
+    R32G32_UINT,
+    R32G32_UNORM,
+    R32G32_USCALED,
+    R32_FIXED,
+    R32_FLOAT,
+    R32_SINT,
+    R32_SNORM,
+    R32_SSCALED,
+    R32_UINT,
+    R32_UNORM,
+    R32_USCALED,
+    R4G4B4A4_UNORM,
+    R5G5B5A1_UNORM,
+    R5G6B5_UNORM,
+    R8G8B8A8_SINT,
+    R8G8B8A8_SNORM,
+    R8G8B8A8_SSCALED,
+    R8G8B8A8_TYPELESS,
+    R8G8B8A8_TYPELESS_SRGB,
+    R8G8B8A8_UINT,
+    R8G8B8A8_UNORM,
+    R8G8B8A8_UNORM_SRGB,
+    R8G8B8A8_USCALED,
+    R8G8B8X8_UNORM,
+    R8G8B8_SINT,
+    R8G8B8_SNORM,
+    R8G8B8_SSCALED,
+    R8G8B8_UINT,
+    R8G8B8_UNORM,
+    R8G8B8_UNORM_SRGB,
+    R8G8B8_USCALED,
+    R8G8_SINT,
+    R8G8_SNORM,
+    R8G8_SSCALED,
+    R8G8_UINT,
+    R8G8_UNORM,
+    R8G8_UNORM_SRGB,
+    R8G8_USCALED,
+    R8_SINT,
+    R8_SNORM,
+    R8_SSCALED,
+    R8_UINT,
+    R8_UNORM,
+    R8_UNORM_SRGB,
+    R8_USCALED,
+    R9G9B9E5_SHAREDEXP,
+    X2R10G10B10_SINT_VERTEX,
+    X2R10G10B10_SNORM_VERTEX,
+    X2R10G10B10_SSCALED_VERTEX,
+    X2R10G10B10_UINT_VERTEX,
+    X2R10G10B10_UNORM_VERTEX,
+    X2R10G10B10_USCALED_VERTEX
+};
+
+}
+
+}
+}
+# 16 "./copy_buffer.metal" 2
+
+using namespace rx::mtl_shader;
+
+constant int kCopyFormatType [[function_constant(10)]];
+
+
+constant int kCopyTextureType [[function_constant(20)]];
+constant bool kCopyTextureType2D = kCopyTextureType == kTextureType2D;
+constant bool kCopyTextureType2DArray = kCopyTextureType == kTextureType2DArray;
+constant bool kCopyTextureType2DMS = kCopyTextureType == kTextureType2DMultisample;
+constant bool kCopyTextureTypeCube = kCopyTextureType == kTextureTypeCube;
+constant bool kCopyTextureType3D = kCopyTextureType == kTextureType3D;
+
+struct CopyPixelParams
+{
+    uint3 copySize;
+    uint3 textureOffset;
+
+    uint bufferStartOffset;
+    uint pixelSize;
+    uint bufferRowPitch;
+    uint bufferDepthPitch;
+};
+
+struct WritePixelParams
+{
+    uint2 copySize;
+    uint2 textureOffset;
+
+    uint bufferStartOffset;
+
+    uint pixelSize;
+    uint bufferRowPitch;
+
+    uint textureLevel;
+    uint textureLayer;
+
+    bool reverseTextureRowOrder;
+};
+# 120 "./copy_buffer.metal"
+template <typename T>
+static inline void textureWrite(ushort3 gIndices,
+                                constant CopyPixelParams &options,
+                                vec<T, 4> color,
+                                texture2d<T, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    uint3 writeIndices = options.textureOffset + uint3(gIndices);
+    switch (kCopyTextureType)
+    {
+        case kTextureType2D:
+            dstTexture2d.write(color, writeIndices.xy);
+            break;
+        case kTextureType2DArray:
+            dstTexture2dArray.write(color, writeIndices.xy, writeIndices.z);
+            break;
+        case kTextureType3D:
+            dstTexture3d.write(color, writeIndices);
+            break;
+        case kTextureTypeCube:
+            dstTextureCube.write(color, writeIndices.xy, writeIndices.z);
+            break;
+    }
+}
+
+
+template <typename T>
+static inline vec<T, 4> textureRead(ushort2 gIndices,
+                                    constant WritePixelParams &options,
+                                    texture2d<T, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<T, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]])
+{
+    vec<T, 4> color;
+    uint2 coords = uint2(gIndices);
+    if (options.reverseTextureRowOrder)
+    {
+        coords.y = options.copySize.y - 1 - gIndices.y;
+    }
+    coords += options.textureOffset;
+    switch (kCopyTextureType)
+    {
+        case kTextureType2D:
+            color = srcTexture2d.read(coords.xy, options.textureLevel);
+            break;
+        case kTextureType2DArray:
+            color = srcTexture2dArray.read(coords.xy, options.textureLayer, options.textureLevel);
+            break;
+        case kTextureType2DMultisample:
+            color = resolveTextureMS(srcTexture2dMS, coords.xy);
+            break;
+        case kTextureType3D:
+            color = srcTexture3d.read(uint3(coords, options.textureLayer), options.textureLevel);
+            break;
+        case kTextureTypeCube:
+            color = srcTextureCube.read(coords.xy, options.textureLayer, options.textureLevel);
+            break;
+    }
+    return color;
+}
+# 215 "./copy_buffer.metal"
+static inline float4 readR5G6B5_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
+    color.g = normalizedToFloat<6>(getShiftedData<6, 5>(src));
+    color.b = normalizedToFloat<5>(getShiftedData<5, 0>(src));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR5G6B5_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
+                 shiftData<6, 5>(floatToNormalized<6, ushort>(color.g)) |
+                 shiftData<5, 0>(floatToNormalized<5, ushort>(color.b));
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR4G4B4A4_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<4>(getShiftedData<4, 12>(src));
+    color.g = normalizedToFloat<4>(getShiftedData<4, 8>(src));
+    color.b = normalizedToFloat<4>(getShiftedData<4, 4>(src));
+    color.a = normalizedToFloat<4>(getShiftedData<4, 0>(src));
+    return color;
+}
+static inline void writeR4G4B4A4_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<4, 12>(floatToNormalized<4, ushort>(color.r)) |
+                 shiftData<4, 8>(floatToNormalized<4, ushort>(color.g)) |
+                 shiftData<4, 4>(floatToNormalized<4, ushort>(color.b)) |
+                 shiftData<4, 0>(floatToNormalized<4, ushort>(color.a));
+    ;
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR5G5B5A1_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
+    color.g = normalizedToFloat<5>(getShiftedData<5, 6>(src));
+    color.b = normalizedToFloat<5>(getShiftedData<5, 1>(src));
+    color.a = normalizedToFloat<1>(getShiftedData<1, 0>(src));
+    return color;
+}
+static inline void writeR5G5B5A1_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
+                 shiftData<5, 6>(floatToNormalized<5, ushort>(color.g)) |
+                 shiftData<5, 1>(floatToNormalized<5, ushort>(color.b)) |
+                 shiftData<1, 0>(floatToNormalized<1, ushort>(color.a));
+    ;
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline int4 readR10G10B10A2_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    int src = bytesToInt<int>(buffer, bufferOffset);
+
+    constexpr int3 rgbSignMask(0x200);
+    constexpr int3 negativeMask(0xfffffc00);
+    constexpr int alphaSignMask = 0x2;
+    constexpr int alphaNegMask = 0xfffffffc;
+
+    color.r = getShiftedData<10, 0>(src);
+    color.g = getShiftedData<10, 10>(src);
+    color.b = getShiftedData<10, 20>(src);
+
+    int3 isRgbNegative = (color.rgb & rgbSignMask) >> 9;
+    color.rgb = (isRgbNegative * negativeMask) | color.rgb;
+
+    color.a = getShiftedData<2, 30>(src);
+    int isAlphaNegative = color.a & alphaSignMask >> 1;
+    color.a = (isAlphaNegative * alphaNegMask) | color.a;
+    return color;
+}
+
+static inline uint4 readR10G10B10A2_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    color.r = getShiftedData<10, 0>(src);
+    color.g = getShiftedData<10, 10>(src);
+    color.b = getShiftedData<10, 20>(src);
+    color.a = getShiftedData<2, 30>(src);
+    return color;
+}
+
+
+static inline float4 readR8G8B8A8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
+{
+    float4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    if (isSRGB)
+    {
+        color = unpack_unorm4x8_srgb_to_float(src);
+    }
+    else
+    {
+        color = unpack_unorm4x8_to_float(src);
+    }
+    return color;
+}
+static inline void writeR8G8B8A8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
+{
+    uint dst;
+
+    if (isSRGB)
+    {
+        dst = pack_float_to_srgb_unorm4x8(color);
+    }
+    else
+    {
+        dst = pack_float_to_unorm4x8(color);
+    }
+
+    intToBytes(dst, bufferOffset, buffer);
+}
+
+static inline float4 readR8G8B8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    color.b = normalizedToFloat<uchar>(buffer[bufferOffset + 2]);
+    color.a = 1.0;
+
+    if (isSRGB)
+    {
+        color = sRGBtoLinear(color);
+    }
+    return color;
+}
+static inline void writeR8G8B8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
+{
+    color.a = 1.0;
+    uint dst;
+
+    if (isSRGB)
+    {
+        dst = pack_float_to_srgb_unorm4x8(color);
+    }
+    else
+    {
+        dst = pack_float_to_unorm4x8(color);
+    }
+    int24bitToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8A8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    color = unpack_snorm4x8_to_float(src);
+
+    return color;
+}
+static inline void writeR8G8B8A8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    uint dst = pack_float_to_snorm4x8(color);
+
+    intToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
+    color.b = normalizedToFloat<7, char>(buffer[bufferOffset + 2]);
+    color.a = 1.0;
+
+    return color;
+}
+static inline void writeR8G8B8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    uint dst = pack_float_to_snorm4x8(color);
+
+    int24bitToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, false);
+}
+static inline void writeR8G8B8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readR8G8B8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, true);
+}
+static inline void writeR8G8B8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readB8G8R8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, false).bgra;
+}
+static inline void writeB8G8R8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    color.rgba = color.bgra;
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readB8G8R8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, true).bgra;
+}
+static inline void writeB8G8R8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    color.rgba = color.bgra;
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readR8G8B8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8(bufferOffset, buffer, false);
+}
+static inline void writeR8G8B8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readR8G8B8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8(bufferOffset, buffer, true);
+}
+static inline void writeR8G8B8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readL8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+}
+
+
+static inline void writeA8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.a);
+}
+
+
+static inline float4 readL8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
+    color.a = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    return color;
+}
+static inline void writeL8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.a);
+}
+
+
+static inline float4 readR8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+}
+
+static inline float4 readR8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
+}
+
+
+static inline int4 readR8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+}
+
+
+static inline uint4 readR8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+}
+
+
+static inline float4 readR8G8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8G8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.g);
+}
+
+static inline float4 readR8G8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8G8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
+    buffer[bufferOffset + 1] = as_type<uchar>(floatToNormalized<7, char>(color.g));
+}
+
+
+static inline int4 readR8G8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8G8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+}
+
+
+static inline uint4 readR8G8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8G8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+}
+
+
+static inline int4 readR8G8B8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = as_type<char>(buffer[bufferOffset + 2]);
+    color.a = 1;
+    return color;
+}
+
+
+static inline uint4 readR8G8B8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
+    color.a = 1;
+    return color;
+}
+
+
+static inline int4 readR8G8B8A8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = as_type<char>(buffer[bufferOffset + 2]);
+    color.a = as_type<char>(buffer[bufferOffset + 3]);
+    return color;
+}
+static inline void writeR8G8B8A8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
+    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
+}
+
+
+static inline uint4 readR8G8B8A8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
+    color.a = as_type<uchar>(buffer[bufferOffset + 3]);
+    return color;
+}
+static inline void writeR8G8B8A8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
+    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
+}
+
+
+static inline float4 readR16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+}
+
+template <typename ShortType>
+static inline float4 readR16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+}
+
+
+static inline uint4 readR16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+}
+
+
+static inline float4 readA16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.rgb = 0.0;
+    return color;
+}
+static inline void writeA16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset, buffer);
+}
+
+
+static inline float4 readL16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+}
+
+
+static inline float4 readL16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    return color;
+}
+static inline void writeL16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 2, buffer);
+}
+
+
+static inline float4 readR16G16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR16G16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR16G16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16G16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
+}
+
+
+static inline uint4 readR16G16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16G16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
+}
+
+
+static inline float4 readR16G16B16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
+    color.a = 1.0;
+    return color;
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16B16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
+    color.a = 1.0;
+    return color;
+}
+
+
+
+static inline int4 readR16G16B16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
+    color.a = 1;
+    return color;
+}
+
+
+static inline uint4 readR16G16B16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR16G16B16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 6));
+    return color;
+}
+static inline void writeR16G16B16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.b)), bufferOffset + 4, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 6, buffer);
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16B16A16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
+    color.a = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 6));
+    return color;
+}
+
+
+
+
+static inline int4 readR16G16B16A16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
+    color.a = bytesToShort<short>(buffer, bufferOffset + 6);
+    return color;
+}
+static inline void writeR16G16B16A16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
+    shortToBytes(static_cast<short>(color.b), bufferOffset + 4, buffer);
+    shortToBytes(static_cast<short>(color.a), bufferOffset + 6, buffer);
+}
+
+
+static inline uint4 readR16G16B16A16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
+    color.a = bytesToShort<ushort>(buffer, bufferOffset + 6);
+    return color;
+}
+static inline void writeR16G16B16A16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
+    shortToBytes(static_cast<ushort>(color.b), bufferOffset + 4, buffer);
+    shortToBytes(static_cast<ushort>(color.a), bufferOffset + 6, buffer);
+}
+
+
+static inline float4 readR32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline float4 readA32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.rgb = 0.0;
+    return color;
+}
+static inline void writeA32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.a), bufferOffset, buffer);
+}
+
+
+static inline float4 readL32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+}
+
+
+static inline int4 readR32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+}
+
+
+static inline float4 readR32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+}
+
+
+static inline float4 readL32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    return color;
+}
+static inline void writeL32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.a), bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR32G32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32G32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32G32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32G32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32B32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
+    color.a = 1.0;
+    return color;
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32B32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32B32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR32G32B32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32G32B32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR32G32B32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 12));
+    return color;
+}
+static inline void writeR32G32B32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
+    intToBytes(as_type<uint>(color.b), bufferOffset + 8, buffer);
+    intToBytes(as_type<uint>(color.a), bufferOffset + 12, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32B32A32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
+    color.a = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 12));
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32B32A32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
+    color.a = bytesToInt<int>(buffer, bufferOffset + 12);
+    return color;
+}
+static inline void writeR32G32B32A32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+    intToBytes(color.b, bufferOffset + 8, buffer);
+    intToBytes(color.a, bufferOffset + 12, buffer);
+}
+
+static inline float4 readR32G32B32A32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
+    color.a = bytesToInt<int>(buffer, bufferOffset + 12) * kDivisor;
+    return color;
+}
+
+
+static inline uint4 readR32G32B32A32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
+    color.a = bytesToInt<uint>(buffer, bufferOffset + 12);
+    return color;
+}
+static inline void writeR32G32B32A32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+    intToBytes(color.b, bufferOffset + 8, buffer);
+    intToBytes(color.a, bufferOffset + 12, buffer);
+}
+# 1292 "./copy_buffer.metal"
+static inline int4 readR8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8_SINT(bufferOffset, buffer); } static inline uint4 readR8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8_UINT(bufferOffset, buffer); } static inline int4 readR8G8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8A8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8A8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_UINT(bufferOffset, buffer); }
+static inline int4 readR16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16_SINT(bufferOffset, buffer); } static inline uint4 readR16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16_UINT(bufferOffset, buffer); } static inline int4 readR16G16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16A16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16A16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_UINT(bufferOffset, buffer); }
+static inline int4 readR32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32_SINT(bufferOffset, buffer); } static inline uint4 readR32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32_UINT(bufferOffset, buffer); } static inline int4 readR32G32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32A32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32A32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_UINT(bufferOffset, buffer); }
+
+static inline int4 readR10G10B10A2_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_SINT(bufferOffset, buffer); } static inline uint4 readR10G10B10A2_USCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_UINT(bufferOffset, buffer); }
+
+
+kernel void readFromBufferToFloatTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<float, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1336 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R5G6B5_UNORM: { auto color = readR5G6B5_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM: { auto color = readR8G8B8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = readR8G8B8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SNORM: { auto color = readR8G8B8A8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM: { auto color = readB8G8R8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = readB8G8R8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM: { auto color = readR8G8B8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = readR8G8B8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SNORM: { auto color = readR8G8B8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8_UNORM: { auto color = readL8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8A8_UNORM: { auto color = readL8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R5G5B5A1_UNORM: { auto color = readR5G5B5A1_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R4G4B4A4_UNORM: { auto color = readR4G4B4A4_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_UNORM: { auto color = readR8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_SNORM: { auto color = readR8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UNORM: { auto color = readR8G8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SNORM: { auto color = readR8G8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_FLOAT: { auto color = readR16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A16_FLOAT: { auto color = readA16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16_FLOAT: { auto color = readL16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16A16_FLOAT: { auto color = readL16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_FLOAT: { auto color = readR16G16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_FLOAT: { auto color = readR16G16B16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = readR16G16B16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_FLOAT: { auto color = readR32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A32_FLOAT: { auto color = readA32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32_FLOAT: { auto color = readL32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32A32_FLOAT: { auto color = readL32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_FLOAT: { auto color = readR32G32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_FLOAT: { auto color = readR32G32B32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = readR32G32B32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+kernel void readFromBufferToIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<int, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1364 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_SINT: { auto color = readR8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SINT: { auto color = readR8G8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SINT: { auto color = readR8G8B8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SINT: { auto color = readR8G8B8A8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_SINT: { auto color = readR16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_SINT: { auto color = readR16G16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_SINT: { auto color = readR16G16B16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_SINT: { auto color = readR16G16B16A16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_SINT: { auto color = readR32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_SINT: { auto color = readR32G32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_SINT: { auto color = readR32G32B32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_SINT: { auto color = readR32G32B32A32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+kernel void readFromBufferToUIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<uint, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1392 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UINT: { auto color = readR8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UINT: { auto color = readR8G8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UINT: { auto color = readR8G8B8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UINT: { auto color = readR8G8B8A8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_UINT: { auto color = readR16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_UINT: { auto color = readR16G16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_UINT: { auto color = readR16G16B16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_UINT: { auto color = readR16G16B16A16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_UINT: { auto color = readR32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_UINT: { auto color = readR32G32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_UINT: { auto color = readR32G32B32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_UINT: { auto color = readR32G32B32A32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+
+kernel void writeFromFloatTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<float, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<float, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1439 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R5G6B5_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G6B5_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R5G5B5A1_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G5B5A1_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R4G4B4A4_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR4G4B4A4_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+kernel void writeFromIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<int, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<int, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1464 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_SINT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+kernel void writeFromUIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<uint, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<uint, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1489 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_UINT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+
+struct CopyVertexParams
+{
+    uint srcBufferStartOffset;
+    uint srcStride;
+    uint srcComponentBytes;
+    uint srcComponents;
+
+
+
+    uchar4 srcDefaultAlphaData;
+
+    uint dstBufferStartOffset;
+    uint dstStride;
+    uint dstComponents;
+
+    uint vertexCount;
+};
+# 1539 "./copy_buffer.metal"
+template <typename IntType>
+static inline void writeFloatVertex(constant CopyVertexParams &options,
+                                    uint idx,
+                                    vec<IntType, 4> data,
+                                    device uchar *dst)
+{
+    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
+
+    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
+    {
+        floatToBytes(static_cast<float>(data[component]), dstOffset, dst);
+    }
+}
+
+template <>
+inline void writeFloatVertex(constant CopyVertexParams &options,
+                             uint idx,
+                             vec<float, 4> data,
+                             device uchar *dst)
+{
+    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
+
+    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
+    {
+        floatToBytes(data[component], dstOffset, dst);
+    }
+}
+
+
+static inline void convertToFloatVertexFormat(uint index,
+                                              constant CopyVertexParams &options,
+                                              constant uchar *srcBuffer,
+                                              device uchar *dstBuffer)
+{
+# 1585 "./copy_buffer.metal"
+    uint bufferOffset = options.srcBufferStartOffset + options.srcStride * index;
+# 1594 "./copy_buffer.metal"
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UNORM: { auto data = readR8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SNORM: { auto data = readR8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_UINT: { auto data = readR8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SINT: { auto data = readR8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_USCALED: { auto data = readR8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SSCALED: { auto data = readR8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UNORM: { auto data = readR8G8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SNORM: { auto data = readR8G8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UINT: { auto data = readR8G8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SINT: { auto data = readR8G8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_USCALED: { auto data = readR8G8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SSCALED: { auto data = readR8G8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UNORM: { auto data = readR8G8B8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SNORM: { auto data = readR8G8B8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UINT: { auto data = readR8G8B8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SINT: { auto data = readR8G8B8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_USCALED: { auto data = readR8G8B8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SSCALED: { auto data = readR8G8B8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UNORM: { auto data = readR8G8B8A8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SNORM: { auto data = readR8G8B8A8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UINT: { auto data = readR8G8B8A8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SINT: { auto data = readR8G8B8A8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_USCALED: { auto data = readR8G8B8A8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SSCALED: { auto data = readR8G8B8A8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UNORM: { auto data = readR16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SNORM: { auto data = readR16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UINT: { auto data = readR16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SINT: { auto data = readR16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_USCALED: { auto data = readR16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SSCALED: { auto data = readR16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UNORM: { auto data = readR16G16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SNORM: { auto data = readR16G16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UINT: { auto data = readR16G16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SINT: { auto data = readR16G16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_USCALED: { auto data = readR16G16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SSCALED: { auto data = readR16G16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UNORM: { auto data = readR16G16B16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SNORM: { auto data = readR16G16B16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UINT: { auto data = readR16G16B16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SINT: { auto data = readR16G16B16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_USCALED: { auto data = readR16G16B16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SSCALED: { auto data = readR16G16B16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UNORM: { auto data = readR16G16B16A16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SNORM: { auto data = readR16G16B16A16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UINT: { auto data = readR16G16B16A16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SINT: { auto data = readR16G16B16A16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_USCALED: { auto data = readR16G16B16A16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SSCALED: { auto data = readR16G16B16A16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UNORM: { auto data = readR32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SNORM: { auto data = readR32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UINT: { auto data = readR32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SINT: { auto data = readR32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_USCALED: { auto data = readR32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SSCALED: { auto data = readR32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UNORM: { auto data = readR32G32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SNORM: { auto data = readR32G32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UINT: { auto data = readR32G32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SINT: { auto data = readR32G32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_USCALED: { auto data = readR32G32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SSCALED: { auto data = readR32G32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UNORM: { auto data = readR32G32B32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SNORM: { auto data = readR32G32B32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UINT: { auto data = readR32G32B32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SINT: { auto data = readR32G32B32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_USCALED: { auto data = readR32G32B32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SSCALED: { auto data = readR32G32B32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UNORM: { auto data = readR32G32B32A32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SNORM: { auto data = readR32G32B32A32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UINT: { auto data = readR32G32B32A32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SINT: { auto data = readR32G32B32A32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_USCALED: { auto data = readR32G32B32A32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SSCALED: { auto data = readR32G32B32A32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_FLOAT: { auto data = readR16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_FLOAT: { auto data = readR16G16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_FLOAT: { auto data = readR16G16B16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto data = readR16G16B16A16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FLOAT: { auto data = readR32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FLOAT: { auto data = readR32G32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FLOAT: { auto data = readR32G32B32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto data = readR32G32B32A32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FIXED: { auto data = readR32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FIXED: { auto data = readR32G32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FIXED: { auto data = readR32G32B32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FIXED: { auto data = readR32G32B32A32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SINT: { auto data = readR10G10B10A2_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_UINT: { auto data = readR10G10B10A2_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SSCALED: { auto data = readR10G10B10A2_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_USCALED: { auto data = readR10G10B10A2_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break;
+    }
+
+
+}
+
+
+kernel void convertToFloatVertexFormatCS(uint index [[thread_position_in_grid]],
+                                         constant CopyVertexParams &options [[buffer(0)]],
+                                         constant uchar *srcBuffer [[buffer(1)]],
+                                         device uchar *dstBuffer [[buffer(2)]])
+{
+    if (index >= options.vertexCount) { return; };
+    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
+}
+
+
+vertex void convertToFloatVertexFormatVS(uint index [[vertex_id]],
+                                         constant CopyVertexParams &options [[buffer(0)]],
+                                         constant uchar *srcBuffer [[buffer(1)]],
+                                         device uchar *dstBuffer [[buffer(2)]])
+{
+    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
+}
+
+
+static inline void expandVertexFormatComponents(uint index,
+                                                constant CopyVertexParams &options,
+                                                constant uchar *srcBuffer,
+                                                device uchar *dstBuffer)
+{
+    uint srcOffset = options.srcBufferStartOffset + options.srcStride * index;
+    uint dstOffset = options.dstBufferStartOffset + options.dstStride * index;
+
+    uint dstComponentsBeforeAlpha = min(options.dstComponents, 3u);
+    uint component;
+    for (component = 0; component < options.srcComponents; ++component,
+        srcOffset += options.srcComponentBytes, dstOffset += options.srcComponentBytes)
+    {
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = srcBuffer[srcOffset + byte];
+        }
+    }
+
+    for (; component < dstComponentsBeforeAlpha;
+         ++component, dstOffset += options.srcComponentBytes)
+    {
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = 0;
+        }
+    }
+
+    if (component < options.dstComponents)
+    {
+
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = options.srcDefaultAlphaData[byte];
+        }
+    }
+}
+
+
+kernel void expandVertexFormatComponentsCS(uint index [[thread_position_in_grid]],
+                                           constant CopyVertexParams &options [[buffer(0)]],
+                                           constant uchar *srcBuffer [[buffer(1)]],
+                                           device uchar *dstBuffer [[buffer(2)]])
+{
+    if (index >= options.vertexCount) { return; };
+
+    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
+}
+
+
+vertex void expandVertexFormatComponentsVS(uint index [[vertex_id]],
+                                           constant CopyVertexParams &options [[buffer(0)]],
+                                           constant uchar *srcBuffer [[buffer(1)]],
+                                           device uchar *dstBuffer [[buffer(2)]])
+{
+    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
+}
+# 6 "temp_master_source.metal" 2
+# 1 "./visibility.metal" 1
+
+
+
+
+
+
+
+
+constant bool kCombineWithExistingResult [[function_constant(1000)]];
+
+
+
+struct CombineVisibilityResultOptions
+{
+
+    uint startOffset;
+
+    uint numOffsets;
+};
+
+kernel void combineVisibilityResult(uint idx [[thread_position_in_grid]],
+                                    constant CombineVisibilityResultOptions &options [[buffer(0)]],
+                                    constant ushort4 *renderpassVisibilityResult [[buffer(1)]],
+                                    device ushort4 *finalResults [[buffer(2)]])
+{
+    if (idx > 0)
+    {
+
+
+
+        return;
+    }
+    ushort4 finalResult16x4;
+
+    if (kCombineWithExistingResult)
+    {
+        finalResult16x4 = finalResults[0];
+    }
+    else
+    {
+        finalResult16x4 = ushort4(0, 0, 0, 0);
+    }
+
+    for (uint i = 0; i < options.numOffsets; ++i)
+    {
+        uint offset = options.startOffset + i;
+        ushort4 renderpassResult = renderpassVisibilityResult[offset];
+
+
+        finalResult16x4 = finalResult16x4 | renderpassResult;
+    }
+    finalResults[0] = finalResult16x4;
+}
+# 7 "temp_master_source.metal" 2
+# 1 "./rewrite_indices.metal" 1
+# 11 "./rewrite_indices.metal"
+# 1 "./rewrite_indices_shared.h" 1
+# 12 "./rewrite_indices.metal" 2
+using namespace metal;
+
+constant uint fixIndexBufferKey [[ function_constant(2000) ]];
+constant bool indexBufferIsUint16 = (((fixIndexBufferKey >> 0U) & 0x03U) == 2U);
+constant bool indexBufferIsUint32 = (((fixIndexBufferKey >> 0U) & 0x03U) == 3U);
+constant bool outIndexBufferIsUint16 = (((fixIndexBufferKey >> 2U) & 0x03U) == 2U);
+constant bool outIndexBufferIsUint32 = (((fixIndexBufferKey >> 2U) & 0x03U) == 3U);
+constant bool doPrimRestart = (fixIndexBufferKey & 0x00100U);
+constant uint fixIndexBufferMode = (fixIndexBufferKey >> 4U) & 0x0FU;
+
+
+static inline uint readIdx(
+                           const device ushort *indexBufferUint16,
+                           const device uint *indexBufferUint32,
+                           const uint restartIndex,
+                           const uint indexCount,
+                           uint idx,
+                           thread bool &foundRestart,
+                           thread uint &indexThatRestartedFirst
+                           )
+{
+    uint inIndex = idx;
+    if(inIndex < indexCount)
+    {
+        if(indexBufferIsUint16)
+        {
+            inIndex = indexBufferUint16[inIndex];
+        }
+        else if(indexBufferIsUint32)
+        {
+            inIndex = indexBufferUint32[inIndex];
+        }
+    }
+    else
+    {
+        foundRestart = true;
+        indexThatRestartedFirst = idx;
+    }
+    if(doPrimRestart && !foundRestart && inIndex == restartIndex)
+    {
+        foundRestart = true;
+        indexThatRestartedFirst = idx;
+    }
+    return inIndex;
+}
+
+static inline void outputPrimitive(
+                                   const device ushort *indexBufferUint16,
+                                   const device uint *indexBufferUint32,
+                                   device ushort *outIndexBufferUint16,
+                                   device uint *outIndexBufferUint32,
+                                   const uint restartIndex,
+                                   const uint indexCount,
+                                   thread uint &baseIndex,
+                                   uint onIndex,
+                                   thread uint &onOutIndex
+                                   )
+{
+    if(baseIndex > onIndex) return;
+    bool foundRestart = false;
+    uint indexThatRestartedFirst = 0;
+# 86 "./rewrite_indices.metal"
+    switch(fixIndexBufferMode)
+    {
+        case 0x00U:
+        {
+            auto tmpIndex = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex; } onOutIndex++; });
+        }
+        break;
+        case 0x01U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+            if((onIndex - baseIndex) & 1) return;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x03U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x04U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+            if(((onIndex - baseIndex) % 3) != 0) return;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x05U:
+        {
+            uint isOdd = ((onIndex - baseIndex) & 1);
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0 + isOdd, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1 - isOdd, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+            else
+            {
+
+                if(isOdd)
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                }
+                else
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                }
+            }
+
+            assert(onOutIndex <= (onIndex + 1) * 3);
+            assert(onOutIndex <= (indexCount - 2) * 3);
+        }
+        break;
+
+    }
+
+
+}
+
+kernel void fixIndexBuffer(
+                           const device ushort *indexBufferUint16 [[ buffer(0), function_constant(indexBufferIsUint16) ]],
+                           const device uint *indexBufferUint32 [[ buffer(0), function_constant(indexBufferIsUint32) ]],
+                           device ushort *outIndexBufferUint16 [[ buffer(1), function_constant(outIndexBufferIsUint16) ]],
+                           device uint *outIndexBufferUint32 [[ buffer(1), function_constant(outIndexBufferIsUint32) ]],
+                           constant uint &indexCount [[ buffer(2) ]],
+                           constant uint &primCount [[ buffer(3) ]],
+                           uint prim [[thread_position_in_grid]])
+{
+    constexpr uint restartIndex = 0xFFFFFFFF;
+    uint baseIndex = 0;
+    uint onIndex = onIndex;
+    uint onOutIndex = onOutIndex;
+    if(prim < primCount)
+    {
+        switch(fixIndexBufferMode)
+        {
+            case 0x00U:
+                onIndex = prim;
+                onOutIndex = prim;
+                break;
+            case 0x01U:
+                onIndex = prim * 2 + 0;
+                onOutIndex = prim * 2 + 0;
+                break;
+            case 0x03U:
+                onIndex = prim;
+                onOutIndex = prim * 2 + 0;
+                break;
+            case 0x04U:
+                onIndex = prim * 3 + 0;
+                onOutIndex = prim * 3 + 0;
+                break;
+            case 0x05U:
+                onIndex = prim;
+                onOutIndex = prim * 3 + 0;
+                break;
+        }
+        outputPrimitive(indexBufferUint16, indexBufferUint32, outIndexBufferUint16, outIndexBufferUint32, restartIndex, indexCount, baseIndex, onIndex, onOutIndex);
+    }
+}
+# 8 "temp_master_source.metal" 2
+
diff --git a/src/libANGLE/validationEGL.h b/src/libANGLE/validationEGL.h
index 1d08552..f166683 100644
--- a/src/libANGLE/validationEGL.h
+++ b/src/libANGLE/validationEGL.h
@@ -119,16 +119,12 @@ inline const AttributeMap PackParam<const AttributeMap &, const EGLint *>(const
     return AttributeMap::CreateFromIntArray(attribs);
 }
 
-// In a 32-bit environment the EGLAttrib and EGLint types are the same. We need to mask out one of
-// the two specializations to avoid having an override ambiguity.
-#if defined(ANGLE_IS_64_BIT_CPU)
 template <>
 inline const AttributeMap PackParam<const AttributeMap &, const EGLAttrib *>(
     const EGLAttrib *attribs)
 {
     return AttributeMap::CreateFromAttribArray(attribs);
 }
-#endif  // defined(ANGLE_IS_64_BIT_CPU)
 
 template <typename PackedT, typename FromT>
 inline typename std::enable_if<!std::is_enum<PackedT>::value,
diff --git a/src/tests/angle_unittests.gni b/src/tests/angle_unittests.gni
index 61345f8..dd70b9f 100644
--- a/src/tests/angle_unittests.gni
+++ b/src/tests/angle_unittests.gni
@@ -166,6 +166,8 @@ if (is_android) {
       [ "compiler_tests/ImmutableString_test_autogen.cpp" ]
 }
 
+angle_unittests_msl_sources = [ "../tests/compiler_tests/MSLOutput_test.cpp" ]
+
 if (!is_android && !is_fuchsia) {
   angle_unittests_sources += [ "test_utils/runner/TestSuite_unittest.cpp" ]
 }
diff --git a/src/tests/deqp_support/deqp_egl_test_expectations.txt b/src/tests/deqp_support/deqp_egl_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_egl_test_expectations.txt
rename to src/tests/deqp_support/deqp_egl_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles2_test_expectations.txt b/src/tests/deqp_support/deqp_gles2_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles2_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles2_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles31_test_expectations.txt b/src/tests/deqp_support/deqp_gles31_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles31_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles31_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles31_rotate_test_expectations.txt b/src/tests/deqp_support/deqp_gles31_rotate_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles31_rotate_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles31_rotate_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles3_test_expectations.txt b/src/tests/deqp_support/deqp_gles3_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles3_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles3_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles3_rotate_test_expectations.txt b/src/tests/deqp_support/deqp_gles3_rotate_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles3_rotate_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles3_rotate_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles2_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles2_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles2_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles2_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles31_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles31_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles31_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles31_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles32_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles32_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles32_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles32_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles3_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles3_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles3_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles3_TestExpectations
diff --git a/third_party/r8/custom_d8.jar b/third_party/r8/custom_d8.jar
deleted file mode 100644
index 99a9106..0000000
Binary files a/third_party/r8/custom_d8.jar and /dev/null differ
